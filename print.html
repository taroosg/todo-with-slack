<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>todo-with-slack</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="api-01/index.html"><strong aria-hidden="true">2.</strong> サーバ編 ①（Node.js）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api-01/about-nodejs.html"><strong aria-hidden="true">2.1.</strong> Node.js とは</a></li><li class="chapter-item expanded "><a href="api-01/prepare-api.html"><strong aria-hidden="true">2.2.</strong> API 実装の準備</a></li><li class="chapter-item expanded "><a href="api-01/install-express.html"><strong aria-hidden="true">2.3.</strong> Express のインストール</a></li><li class="chapter-item expanded "><a href="api-01/omikuji-api01.html"><strong aria-hidden="true">2.4.</strong> API 実装 1（おみくじ初級編）</a></li><li class="chapter-item expanded "><a href="api-01/add-command.html"><strong aria-hidden="true">2.5.</strong> コマンドの追加</a></li><li class="chapter-item expanded "><a href="api-01/omikuji-api02.html"><strong aria-hidden="true">2.6.</strong> API 実装 2（おみくじ中級編）</a></li><li class="chapter-item expanded "><a href="api-01/janken-api.html"><strong aria-hidden="true">2.7.</strong> API 実装 3（じゃんけん）</a></li><li class="chapter-item expanded "><a href="api-01/summary.html"><strong aria-hidden="true">2.8.</strong> まとめ</a></li><li class="chapter-item expanded "><a href="api-01/work.html"><strong aria-hidden="true">2.9.</strong> 課題</a></li></ol></li><li class="chapter-item expanded "><a href="api-02/index.html"><strong aria-hidden="true">3.</strong> サーバ編 ②（Node.js）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api-02/about-perpetuation.html"><strong aria-hidden="true">3.1.</strong> データの永続化について</a></li><li class="chapter-item expanded "><a href="api-02/setup-supabase.html"><strong aria-hidden="true">3.2.</strong> Supabase の準備</a></li><li class="chapter-item expanded "><a href="api-02/setup-files.html"><strong aria-hidden="true">3.3.</strong> ファイル作成と動作確認</a></li><li class="chapter-item expanded "><a href="api-02/crud-create.html"><strong aria-hidden="true">3.4.</strong> Create の処理</a></li><li class="chapter-item expanded "><a href="api-02/crud-read-all.html"><strong aria-hidden="true">3.5.</strong> Read の処理（全件）</a></li><li class="chapter-item expanded "><a href="api-02/crud-read-today.html"><strong aria-hidden="true">3.6.</strong> Read の処理（本日以前）</a></li><li class="chapter-item expanded "><a href="api-02/crud-update.html"><strong aria-hidden="true">3.7.</strong> Update の処理</a></li><li class="chapter-item expanded "><a href="api-02/crud-delete.html"><strong aria-hidden="true">3.8.</strong> Delete の処理</a></li><li class="chapter-item expanded "><a href="api-02/connect-to-slack.html"><strong aria-hidden="true">3.9.</strong> Slack 連携設定</a></li><li class="chapter-item expanded "><a href="api-02/post-to-slack.html"><strong aria-hidden="true">3.10.</strong> Slack 連携実装</a></li><li class="chapter-item expanded "><a href="api-02/summary.html"><strong aria-hidden="true">3.11.</strong> まとめ</a></li></ol></li><li class="chapter-item expanded "><a href="app-01/index.html"><strong aria-hidden="true">4.</strong> フロント編 ①（React）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app-01/about-react.html"><strong aria-hidden="true">4.1.</strong> React とは</a></li><li class="chapter-item expanded "><a href="app-01/construct-app.html"><strong aria-hidden="true">4.2.</strong> アプリケーション実装の準備</a></li><li class="chapter-item expanded "><a href="app-01/use-component.html"><strong aria-hidden="true">4.3.</strong> コンポーネント</a></li><li class="chapter-item expanded "><a href="app-01/use-props.html"><strong aria-hidden="true">4.4.</strong> props の活用</a></li><li class="chapter-item expanded "><a href="app-01/use-router.html"><strong aria-hidden="true">4.5.</strong> router 機能</a></li><li class="chapter-item expanded "><a href="app-01/props-function.html"><strong aria-hidden="true">4.6.</strong> 子コンポーネントへの関数入力</a></li><li class="chapter-item expanded "><a href="app-01/http-request.html"><strong aria-hidden="true">4.7.</strong> http リクエストの実装</a></li><li class="chapter-item expanded "><a href="app-01/ui.html"><strong aria-hidden="true">4.8.</strong> 表示の調整</a></li><li class="chapter-item expanded "><a href="app-01/summary.html"><strong aria-hidden="true">4.9.</strong> まとめ</a></li><li class="chapter-item expanded "><a href="app-01/work.html"><strong aria-hidden="true">4.10.</strong> 課題</a></li></ol></li><li class="chapter-item expanded "><a href="app-02/index.html"><strong aria-hidden="true">5.</strong> フロント編 ②（React）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="app-02/setup-server.html"><strong aria-hidden="true">5.1.</strong> サーバ側の準備</a></li><li class="chapter-item expanded "><a href="app-02/create-pages.html"><strong aria-hidden="true">5.2.</strong> 必要な画面の準備</a></li><li class="chapter-item expanded "><a href="app-02/todo-post.html"><strong aria-hidden="true">5.3.</strong> todo 送信画面の作成</a></li><li class="chapter-item expanded "><a href="app-02/todo-index.html"><strong aria-hidden="true">5.4.</strong> todo 一覧画面（全件）の作成</a></li><li class="chapter-item expanded "><a href="app-02/setup-component.html"><strong aria-hidden="true">5.5.</strong> コンポーネントの最適化</a></li><li class="chapter-item expanded "><a href="app-02/todo-update.html"><strong aria-hidden="true">5.6.</strong> todo 更新処理の作成</a></li><li class="chapter-item expanded "><a href="app-02/todo-delete.html"><strong aria-hidden="true">5.7.</strong> todo 削除処理の作成</a></li><li class="chapter-item expanded "><a href="app-02/todo-today.html"><strong aria-hidden="true">5.8.</strong> todo 一覧画面（本日）の作成</a></li><li class="chapter-item expanded "><a href="app-02/swr-setup.html"><strong aria-hidden="true">5.9.</strong> データ取得タイミングの最適化</a></li><li class="chapter-item expanded "><a href="app-02/swr-polling.html"><strong aria-hidden="true">5.10.</strong> データ取得タイミングの調整</a></li><li class="chapter-item expanded "><a href="app-02/test-slack.html"><strong aria-hidden="true">5.11.</strong> Slack 連携機能のテスト画面実装</a></li><li class="chapter-item expanded "><a href="app-02/summary.html"><strong aria-hidden="true">5.12.</strong> まとめ</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">todo-with-slack</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="はじめに"><a class="header" href="#はじめに">はじめに</a></h1>
<p>本講座では，Node.js と React を用いた todo アプリケーション開発に挑戦します．</p>
<p>どちらも JavaScript で記述を行うため，言語を少し触った人であれば問題なくコードを書くことができます．</p>
<p>全 4 回を通して todo アプリケーションを実装しながら，基本的な実装方法やポイントとなる考え方を押さえます．</p>
<h2 id="実装するアプリケーション"><a class="header" href="#実装するアプリケーション">実装するアプリケーション</a></h2>
<p>アプリケーションの全体像はサーバサイドとフロントエンドが API を通じて連携する構成となっています．サーバ側の API は Node.js，フロント側は React で実装します．</p>
<p>開発時にはサーバ - フロント間で通信に用いるデータの形式を定めておき，サーバとフロントはそれぞれ独立させて実装を進めます．このような開発を「スキーマ駆動開発」と呼びます．</p>
<h3 id="サーバサイドの実装"><a class="header" href="#サーバサイドの実装">サーバサイドの実装</a></h3>
<p>まず始めに Node.js 側でアプリケーションの機能を一通り実装します．ここでは基本の CRUD 処理を中心とし，BaaS を用いたデータの永続化，Slack との連携機能を取り入れます．</p>
<p>この時点ではターミナルからのコマンド操作で各機能が動作する状態になります．</p>
<ul>
<li>
<p>アプリケーションの機能一覧（サーバ側）</p>
<ul>
<li>
<p>新規 todo の作成．</p>
</li>
<li>
<p>todo 全件の一覧表示．</p>
</li>
<li>
<p>締切が実行日以前の todo 一覧表示．</p>
</li>
<li>
<p>既存 todo の更新．</p>
</li>
<li>
<p>既存 todo の削除．</p>
</li>
<li>
<p>todo 全件を指定時間に Slack の指定チャンネルに投稿．</p>
</li>
<li>
<p>締切が実行日以前の todo を指定時間に Slack の指定チャンネルに投稿．</p>
</li>
</ul>
</li>
</ul>
<h3 id="フロントエンドの実装"><a class="header" href="#フロントエンドの実装">フロントエンドの実装</a></h3>
<p>続いて，React を用いてフロントエンドの実装を行います．先に実装したサーバ側アプリケーションと連携することで，全ての機能をブラウザからの操作で実行することが可能になります．</p>
<ul>
<li>
<p>アプリケーションの画面構成（フロント側）</p>
<ul>
<li>
<p>todo 入力画面（新規 todo 作成を実行）．</p>
</li>
<li>
<p>todo 全件一覧画面（データ全件取得，更新，削除を実行）．</p>
</li>
<li>
<p>締切が実行日以前の todo 一覧画面（データ一部取得，更新，削除を実行）．</p>
</li>
</ul>
</li>
</ul>
<h2 id="講座の流れ"><a class="header" href="#講座の流れ">講座の流れ</a></h2>
<p>講座の流れは以下のとおりです．</p>
<ul>
<li>
<p>第 1 回目</p>
<ul>
<li>Node.js の基本的な動かし方，実装方法を学ぶ．</li>
</ul>
</li>
<li>
<p>第 2 回目</p>
<ul>
<li>Node.js を用いて，アプリケーション（サーバ側）の実装を行う．</li>
</ul>
</li>
<li>
<p>第 3 回目</p>
<ul>
<li>React の基本的な動かし方，実装方法を学ぶ．</li>
</ul>
</li>
<li>
<p>第 4 回目</p>
<ul>
<li>React を用いて，アプリケーション（フロント側）の実装を行う．</li>
</ul>
</li>
</ul>
<h2 id="事前準備"><a class="header" href="#事前準備">事前準備</a></h2>
<p>Node.js の動作する環境が必要となる．ターミナルで以下のコマンドを実行し，バージョンが表示されれば OK．</p>
<p>Node.js をインストールする方法は複数あるが，どの方法でも良い．</p>
<pre><code class="language-bash">$ node -v
v16.13.0

# v16.*.* であればOK．

</code></pre>
<pre><code class="language-bash">$ npm -v
8.1.0

# 8.*.* であればOK．

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="サーバ編-①nodejs"><a class="header" href="#サーバ編-①nodejs">サーバ編 ①（Node.js）</a></h1>
<h2 id="今回のゴール"><a class="header" href="#今回のゴール">今回のゴール</a></h2>
<ul>
<li>Node.js と Express で簡単な API を体験する．</li>
<li>実装のしかたを複数学び，見通しの良いコードの構造を把握する．</li>
<li>サーバで動作する「おみくじ」と「じゃんけん」を実装する．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-とは"><a class="header" href="#nodejs-とは">Node.js とは</a></h1>
<p>サーバで JavaScript を動かす環境のこと．
「Node.js」という言語があるわけではないので認識違いに注意．</p>
<h2 id="web-アプリケーションの仕組みapi-を実装する場合"><a class="header" href="#web-アプリケーションの仕組みapi-を実装する場合">Web アプリケーションの仕組み（API を実装する場合）</a></h2>
<p>基本は「リクエスト」と「レスポンス」．PHP など他の言語と同じ．</p>
<p>サーバ側でリクエストを受ける URI（Uniform Resource Identifier の略．URL とほぼ同義）を用意しておき，そこにクライアント（ブラウザなど）からリクエストを送信する．</p>
<p>リクエストを受けると記述されたコードが実行され，データなどが返される（JSON 形式が多い）．</p>
<h2 id="express"><a class="header" href="#express">Express</a></h2>
<p>Express は Node.js を用いて Web アプリケーションを構築するためのフレームワーク．</p>
<p>Node.js は自由度が非常に高く，そのまま書くと人によって千差万別となる．したがって，Web 開発をするときは Express を使用するのがデファクトスタンダードとなっている状態である（他にもフレームワークは存在するが，Express を基にしたものが多い）．</p>
<p>Express は構造が簡易であり，API の実装も非常に簡単である．今回は Express を使っていくつかの API を実装してみる．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api-実装の準備"><a class="header" href="#api-実装の準備">API 実装の準備</a></h1>
<p>Node.js のプロジェクトを実装し，動かしてみる．</p>
<h2 id="プロジェクト作成"><a class="header" href="#プロジェクト作成">プロジェクト作成</a></h2>
<p>プロジェクトを作成するには，下記のコマンドを実行する．</p>
<pre><code class="language-bash">$ mkdir express-project &amp;&amp; cd express-project
$ npm init
</code></pre>
<p><code>npm</code>は<code>node package module</code>の略であり，Node.js 上で動くパッケージを管理するツールである．Node.js で開発を行う場合はこれを用いることがほとんどである．</p>
<p>ダイアログが出てくるので，答えていく．全部そのまま Enter で OK．</p>
<pre><code class="language-bash">This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt;` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (express-project)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to /home/taroosg/Desktop/express-project/package.json:

{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}


Is this OK? (yes)

</code></pre>
<p>完了したらエディタで開く．</p>
<p>エディタで開いたら<code>package.json</code>が作成されているので，中身を確認する．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}

</code></pre>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>name</td><td>プロダクト名．</td></tr>
<tr><td>version</td><td>プロダクトのバージョン．</td></tr>
<tr><td>description</td><td>プロダクトの説明．</td></tr>
<tr><td>main</td><td>プロダクトをパッケージとして公開する場合に入り口となるファイルを指定する．</td></tr>
<tr><td>script</td><td>開発者が任意に作成するコマンド．</td></tr>
<tr><td>auther</td><td>開発者情報．1 人のみ記述する．</td></tr>
<tr><td>license</td><td>ライセンス情報．</td></tr>
</tbody></table>
<h2 id="packagejsonに追記"><a class="header" href="#packagejsonに追記"><code>package.json</code>に追記</a></h2>
<p>下記の内容を追記する．</p>
<pre><code class="language-json">&quot;type&quot;: &quot;module&quot;,
</code></pre>
<p>追記後は以下のような状態．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}

</code></pre>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p><code>package.json</code>に<code>&quot;type&quot;: &quot;module&quot;</code>を追記することで<code>import</code>形式で別ファイルを読みこむことができる．
この追記を行わない場合，外部ファイルを読み込む際には<code>require()</code>関数を用いる．
前回のReactなどでは<code>import</code>が基本となっており，こちらに揃えておいたほうがメリットが大きくオススメである．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="expressのインストール"><a class="header" href="#expressのインストール">Expressのインストール</a></h1>
<p>今回は Express のフレームワークを使用するため，下記コマンドで</p>
<pre><code class="language-bash">$ npm i express
</code></pre>
<p>実行結果</p>
<pre><code class="language-bash">+ express@4.17.1
added 50 packages from 37 contributors and audited 50 packages in 1.687s
found 0 vulnerabilities

</code></pre>
<p>完了したら，再度<code>package.json</code>を開き，以下の内容が追加されていることを確認する．</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;express&quot;: &quot;^4.17.1&quot;
}

</code></pre>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>dependencies</td><td>このプロダクトが依存するパッケージの一覧．</td></tr>
</tbody></table>
<p><code>dependencies</code>の中にインストールしたパッケージが追加される仕組み．パッケージとはいろいろな機能をまとめてインストールできるようにしたものであり，様々なものが公開されている．ライブラリとほぼ同義．</p>
<p>また，インストールされたパッケージは同時に作成される<code>node_modules</code>ディレクトリ内に保存される．このディレクトリはパッケージ専用なので，自分で触ることは殆ど無い．</p>
<p><code>package-lock.json</code>には実際にインストールしたパッケージのバージョンが記載される．基本的に触らない．</p>
<p><code>package.json</code>にはプロダクトに必要なパッケージがすべて記載される．コマンド<code>npm install</code>を実行すると，ここに記載されたパッケージがすべてインストールされる．</p>
<p>プロダクトで使用されているライブラリなどを確認できるため，他の人が書いたコードを見るときもチェックすることをオススメ．</p>
<h2 id="gitignoreファイルの作成"><a class="header" href="#gitignoreファイルの作成"><code>.gitignore</code>ファイルの作成</a></h2>
<p>ソースコードを Git で管理することは周知のことであるが，プロジェクト内には Git で管理したくないファイルやディレクトリも存在する．</p>
<p>例えば，上記で作成された<code>node_modules</code>ディレクトリにはインストールしたパッケージだけでなく，「パッケージが必要としている別のパッケージ」もインストールされる．そのため，これらすべてを Git で管理するとファイル数が膨大になってしまう．</p>
<p>そのため，<code>node_modules</code>ディレクトリ（とその他 Git 管理したくないファイル）を<code>.gitignore</code>と呼ばれるファイルにリストアップすることで Git の管理外に措くことができる．</p>
<p>エディタで<code>.gitignore</code>を作成する．必ずプロジェクト直下に作成すること．</p>
<p>作成したら以下の内容を記述しよう．<code>.gitignore</code>から見た相対パスで Git 管理外にしたいファイルやディレクトリを指定している．</p>
<pre><code class="language-txt">/node_modules
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装1おみくじ初級編"><a class="header" href="#api実装1おみくじ初級編">API実装1（おみくじ初級編）</a></h1>
<h2 id="実行用ファイルの作成"><a class="header" href="#実行用ファイルの作成">実行用ファイルの作成</a></h2>
<p>実行するための<code>app.js</code>ファイルを作成する．エディタから作成すれば OK．</p>
<p>ファイルを作成したら下記の内容を記述する．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;

const app = express();
const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.send(&quot;Hello Node.js!&quot;);
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<p>上記のコードは<code>app.js</code>が実行されると，<code>http://localhost:3001</code>でサーバが立ち上がることを示している．</p>
<p>また，<code>http://localhost:3001/</code>に<code>GET</code>でリクエストが来ると，<code>Hello Node.js!</code>というレスポンスを返すよう記述している．</p>
<h2 id="動作確認"><a class="header" href="#動作確認">動作確認</a></h2>
<p>上記を記述したら，ターミナルで以下のコマンドを実行し，サーバを起動する．実行する際には作業ディレクトリに移動しておくこと．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>実行結果．下記のようにサーバが立ち上がれば成功．</p>
<pre><code class="language-bash">Example app listening at http://localhost:3001
</code></pre>
<p>立ち上がったら，別のターミナルで下記コマンドを実行し，リクエストとレスポンスが適切に処理されることを確認する．</p>
<p>コマンドを実行してメッセージが返ってくれば成功．</p>
<pre><code class="language-bash">$ curl localhost:3001
Hello Node.js!
</code></pre>
<p><code>curl</code>はターミナルから http リクエストを送るコマンド．インストールされていない場合はインストールしておく．</p>
<p>サーバを終了する場合は<code>ctrl + c</code>で終了できる．</p>
<h2 id="uri-の追加"><a class="header" href="#uri-の追加">URI の追加</a></h2>
<p><code>/</code>以外にも URI と作成してみる．</p>
<p><code>app.js</code>を以下のように編集する．<code>/omikuji</code>，<code>/janken</code>の 2 つの URI を追加し，各レスポンスを JSON 形式で返すよう変更している．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;

const app = express();
const port = 3001;

// 編集
app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

// 追加
app.get(&quot;/omikuji&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/omikuji&quot;,
    message: &quot;This is Omikuji URI!&quot;,
  });
});

// 追加
app.get(&quot;/janken&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/janken&quot;,
    message: &quot;This is Janken URI!&quot;,
  });
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="動作確認-1"><a class="header" href="#動作確認-1">動作確認</a></h2>
<p>記述したら，再度下記コマンドでサーバを立ち上げる．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>別のターミナルから，<code>curl</code>コマンドで動作を確認する．</p>
<pre><code class="language-bash">$ curl localhost:3001/
{&quot;uri&quot;:&quot;/&quot;,&quot;message&quot;:&quot;Hello Node.js!&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;This is Omikuji URI!&quot;}

$ curl localhost:3001/janken
{&quot;uri&quot;:&quot;/janken&quot;,&quot;message&quot;:&quot;This is Janken URI!&quot;}

</code></pre>
<p>簡単であるがこれだけで API を実装することができた．</p>
<h2 id="演習おみくじ処理の追加"><a class="header" href="#演習おみくじ処理の追加">【演習】おみくじ処理の追加</a></h2>
<p>実際におみくじの処理を追加してみよう．</p>
<p><code>app.js</code>の以下の部分におみくじの処理を書いて動作を確認しよう．サーバを起動し，以下のような結果になるように実装する．何回か実行して異なる結果が返ってくれば OK！</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;大吉&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;凶&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;中吉&quot;}

</code></pre>
<p>実装例：</p>
<pre><code class="language-js">// app.js

// 省略

app.get(&quot;/omikuji&quot;, (req, res) =&gt; {
  const omikuji = [&quot;大吉&quot;, &quot;中吉&quot;, &quot;小吉&quot;, &quot;凶&quot;, &quot;大凶&quot;];
  const min = 0;
  const max = omikuji.length - 1;
  const index = Math.floor(Math.random() * (max - min + 1)) + min;
  res.json({
    uri: &quot;/omikuji&quot;,
    message: omikuji[index],
  });
});

// 省略

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コマンドの追加"><a class="header" href="#コマンドの追加">コマンドの追加</a></h1>
<p>ここまで，下記コマンドでサーバを実行していた．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>これとは別に，プロジェクトに対して自分でコマンドを作成することができる．</p>
<p>コマンドを追加する場合は<code>package.json</code>に記述する．下記の内容を追記してみよう．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;__comment&quot;: &quot;↓ここを追記（この行は書かなくてOK）&quot;,
    &quot;start&quot;: &quot;node app.js&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;^4.17.1&quot;
  }
}
</code></pre>
<p>このように記述すると，<code>npm start</code>というコマンドを実行すると<code>node app.js</code>が実行される．</p>
<p>プロジェクトが複雑になると，場面に応じて様々なコマンドを実行したい場合がある．そのようなときに，統一されたコマンドを準備しておくことで開発をスムーズに進めることができる．</p>
<p>下記を実行するとサーバが立ち上がる．これまでと同じ動作であることを確認しよう．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装2おみくじ中級編"><a class="header" href="#api実装2おみくじ中級編">API実装2（おみくじ中級編）</a></h1>
<p>簡単な API を実装するだけならば，ここまでの内容で十分である．おみくじの処理部分に適当な記述をすれば問題ないであろう．</p>
<p>しかし，コードの記述量が増えてくると，見通しが悪くなってしまい，保守管理にも支障をきたす．</p>
<p>そこで，処理中の役割毎に別ファイルに記述できるようにディレクトリ構成を変更する（責務の分離，などと呼ばれる）．</p>
<h2 id="ディレクトリ構造と役割"><a class="header" href="#ディレクトリ構造と役割">ディレクトリ構造と役割</a></h2>
<p>大きく<code>routes</code>，<code>controllers</code>，<code>services</code>の 3 つに分離する．DB などと組み合わせてデータを扱う場合は他に<code>model</code>を用意するが今回は省略する．</p>
<p>各要素の役割は以下の通り．</p>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>routes</td><td>URI と実行する処理の対応．</td></tr>
<tr><td>controllers</td><td>リクエストパラメータの検証，レスポンス送信．</td></tr>
<tr><td>services</td><td>リクエストに対する処理のメインロジックを記述．</td></tr>
<tr><td>repositories</td><td>DB関連の処理を記述．今回は出番なし．</td></tr>
</tbody></table>
<p>このような役割分担とするため，以下のようにディレクトリとファイルを作成する．</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   └── omikuji.controller.js
├── node_modules
├── package.json
├── package-lock.json
├── routes
│   └── omikuji.route.js
└── services
    └── omikuji.service.js

</code></pre>
<h2 id="実行ファイルの実装"><a class="header" href="#実行ファイルの実装">実行ファイルの実装</a></h2>
<p><code>app.js</code>を以下のように編集する．</p>
<p>ルーティングは routes 以下のファイルに任せ，指定したファイルを読み込むよう記述．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
// おみくじのrouterを読み込む
import { omikujiRouter } from &quot;./routes/omikuji.route.js&quot;;

const app = express();
const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

// おみくじのルーティングを変更
app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));

app.get(&quot;/janken&quot;, (req, res) =&gt; {
  res.json({ message: &quot;This is Janken URI!&quot; });
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="ルーティングの実装"><a class="header" href="#ルーティングの実装">ルーティングの実装</a></h2>
<p><code>routes/omikuji.route.js</code>に以下の内容を記述する．</p>
<p>URI と対応するコントローラの処理を記述する．</p>
<pre><code class="language-js">// routes/omikuji.route.js

import express from &quot;express&quot;;
import { getResult } from &quot;../controllers/omikuji.controller.js&quot;

export const omikujiRouter = express.Router();

omikujiRouter.get(&quot;/&quot;, (req, res) =&gt; getResult(req, res));

</code></pre>
<h2 id="コントローラの実装"><a class="header" href="#コントローラの実装">コントローラの実装</a></h2>
<p><code>controllers/omikuji.controller.js</code>に以下の内容を記述する．</p>
<p>サービスを呼び出して実行したいメソッドを指定し，結果によってレスポンスを指定する．</p>
<pre><code class="language-js">// controllers/omikuji.controller.js

import { getOmikuji } from &quot;../services/omikuji.service.js&quot;;

export const getResult = async (req, res, next) =&gt; {
  try {
    const result = await getOmikuji({});
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Omikuji!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの実装"><a class="header" href="#サービスの実装">サービスの実装</a></h2>
<p><code>services/omikuji.service.js</code>に以下の内容を記述する．</p>
<p>サービスでは実行したいロジックを書く．ここでおみくじのロジックを実装している．</p>
<pre><code class="language-js">// services/omikuji.service.js

export const getOmikuji = async (query) =&gt; {
  try {
    const omikuji = [&quot;大吉&quot;, &quot;中吉&quot;, &quot;小吉&quot;, &quot;凶&quot;, &quot;大凶&quot;];
    const min = 0;
    const max = omikuji.length - 1;
    const index = Math.floor(Math.random() * (max - min + 1)) + min;
    return { result: omikuji[index] };
  } catch (e) {
    throw Error(&quot;Error while getting Omikuji.&quot;);
  }
};

</code></pre>
<p>処理の順序としては以下のようになる．</p>
<pre><code class="language-txt">リクエスト               レスポンス
   ↓                       ↑
routes/omikuji.route.js    |
   ↓                       |
controllers/omikuji.controller.js
   ↓           ↑
ervices/omikuji.service.js

</code></pre>
<h2 id="動作確認-2"><a class="header" href="#動作確認-2">動作確認</a></h2>
<p>サーバを立ち上げ，以下のコマンドでリクエストを送信する．</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
</code></pre>
<p>おみくじの結果が返ってくれば成功．数回実行し，異なる結果が返ってくることを確認しておこう．</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;凶&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;大凶&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;中吉&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;大吉&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

</code></pre>
<p>ユーザに返すレスポンスを変更したい場合はコントローラを，処理の内容を更新したい場合はサービスを書き換えれば良い．このように，各責務を別の場所に置くことでメンテナンスしやすいプロダクトになる．</p>
<p>これでおみくじの実装は完了である．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装3じゃんけん"><a class="header" href="#api実装3じゃんけん">API実装3（じゃんけん）</a></h1>
<p>おみくじの実装ができたので，ユーザ側からデータを送信してじゃんけんの結果を返す API を実装してみる．</p>
<h2 id="アプリケーションの全体像"><a class="header" href="#アプリケーションの全体像">アプリケーションの全体像</a></h2>
<p>ユーザはリクエスト時に<code>post</code>メソッドで自分の手を送信する．サーバ側はユーザから送信された手に対してランダムで手を出し，「ユーザの手」「サーバの手」「勝敗」をレスポンスで返却する．</p>
<p>下図を参考に，必要なファイルを作成する．</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   ├── janken.controller.js
│   └── omikuji.controller.js
├── node_modules
├── package.json
├── package-lock.json
├── routes
│   ├── janken.route.js
│   └── omikuji.route.js
└── services
    ├── janken.service.js
    └── omikuji.service.js

</code></pre>
<h2 id="各ファイルの実装"><a class="header" href="#各ファイルの実装">各ファイルの実装</a></h2>
<p><code>app.js</code>を以下のように編集する．</p>
<p>じゃんけんのルーティングを読み込む．また，POST メソッドでデータを受け取るためには<code>express.urlencoded({ extended: true })</code>とJSONデータの扱いで<code>express.json()</code>が必要になるため読み込んでいる．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
import { omikujiRouter } from &quot;./routes/omikuji.route.js&quot;;
// じゃんけんのルーティングを読み込む
import { jankenRouter } from &quot;./routes/janken.route.js&quot;;

const app = express();
// ↓POSTでデータを受け取るために必要
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));
// じゃんけんのルーティングを追加
app.use(&quot;/janken&quot;, (req, res) =&gt; jankenRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="ルーティングの実装-1"><a class="header" href="#ルーティングの実装-1">ルーティングの実装</a></h2>
<p><code>routes/janken.route.js</code>に以下の内容を記述する．</p>
<p>URI と対応するコントローラの処理を記述する．今回は POST で受け取る点と送信されてきたデータが<code>req</code>に入っている点に注意．</p>
<pre><code class="language-js">// routes/janken.route.js

import express from &quot;express&quot;;
import { getResult } from &quot;../controllers/janken.controller.js&quot;;

export const jankenRouter = express.Router();

jankenRouter.post(&quot;/&quot;, (req, res) =&gt; getResult(req, res));

</code></pre>
<h2 id="コントローラの実装-1"><a class="header" href="#コントローラの実装-1">コントローラの実装</a></h2>
<p><code>controllers/janken.controller.js</code>に以下の内容を記述する．</p>
<p>おみくじの場合とほぼ同じ．</p>
<pre><code class="language-js">// controllers/janken.controller.js

import { getJanken } from &quot;../services/janken.service.js&quot;;

export const getResult = async (req, res, next) =&gt; {
  try {
    const result = await getJanken(req.body);
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Janken!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの実装-1"><a class="header" href="#サービスの実装-1">サービスの実装</a></h2>
<p><code>services/janken.service.js</code>に以下の内容を記述する．</p>
<p>とりあえず毎回同じ結果を返している．</p>
<pre><code class="language-js">// services/janken.service.js

export const getJanken = async (query) =&gt; {
  try {
    return { yourHand: query.myhand, comHand: &quot;グー&quot;, result: &quot;テスト中&quot; };
  } catch (e) {
    throw Error(&quot;Error while getting Janken&quot;);
  }
};

</code></pre>
<h2 id="動作確認-3"><a class="header" href="#動作確認-3">動作確認</a></h2>
<p>サーバを立ち上げて，<code>curl</code>コマンドでリクエストを送信する．POST する場合は下記の書式で実行する．</p>
<p>結果が返ってくれば成功．</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;パー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;パー&quot;,&quot;comHand&quot;:&quot;グー&quot;,&quot;result&quot;:&quot;テスト中&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}
</code></pre>
<p>サーバに対して<code>{&quot;myhand&quot;:&quot;パー&quot;}</code>という JSON 形式のデータを POST メソッドで送信している．</p>
<h2 id="演習じゃんけんの実装"><a class="header" href="#演習じゃんけんの実装">【演習】じゃんけんの実装</a></h2>
<p>上記で記述した<code>services/janken.service.js</code>にじゃんけんのロジックを実装してみよう．</p>
<p>サーバを立ち上げて，以下のようにじゃんけんができれば OK！</p>
<pre><code class="language-js">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;グー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;グー&quot;,&quot;comHand&quot;:&quot;チョキ&quot;,&quot;result&quot;:&quot;Win&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;チョキ&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;チョキ&quot;,&quot;comHand&quot;:&quot;パー&quot;,&quot;result&quot;:&quot;Win&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;パー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;パー&quot;,&quot;comHand&quot;:&quot;チョキ&quot;,&quot;result&quot;:&quot;Lose&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

</code></pre>
<p>じゃんけんができたら，グーチョキパー以外の手を送信すると NG なメッセージが返す実装にもチャレンジ！</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;無敵のアレ&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;message&quot;:&quot;Invalid hand...&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

</code></pre>
<p>実装例：</p>
<pre><code class="language-js">// services/janken.service.js

export const getJanken = async (query) =&gt; {
  try {
    const hand = [&quot;グー&quot;, &quot;チョキ&quot;, &quot;パー&quot;];
    const myIndex = hand.indexOf(query.myhand);
    if (myIndex === -1) return { message: &quot;Invalid hand...&quot; };
    const comIndex = Math.floor(Math.random() * 3);
    const resultSheet = [
      [&quot;Draw&quot;, &quot;Win&quot;, &quot;Lose&quot;],
      [&quot;Lose&quot;, &quot;Draw&quot;, &quot;Win&quot;],
      [&quot;Win&quot;, &quot;Lose&quot;, &quot;Draw&quot;],
    ];
    return {
      yourHand: query.myhand,
      comHand: hand[comIndex],
      result: resultSheet[myIndex][comIndex],
    };
  } catch (e) {
    throw Error(&quot;Error while getting Janken&quot;);
  }
};

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h1>
<p>今回は Node.js を用いて API サーバを実装してみた．</p>
<p>おみくじやじゃんけんの実装を通じて，必要な処理に含まれる責務を分離し，別々のファイルに実装した．</p>
<p>Node.js はシンプルな構成で柔軟な API を構築できる魅力的な技術である．興味を持った方は，じゃんけんの勝率変更や DB 連携などにも挑戦してみると良いだろう．</p>
<p>今回は以上である( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="課題"><a class="header" href="#課題">課題</a></h1>
<p>下記の実装に挑戦しよう．</p>
<p>成果物は GitHub の URL を Slack の指定したチャンネルに投稿すること．</p>
<ul>
<li>Node.js を用いたオリジナルの API を実装する．</li>
</ul>
<p>今回はここまで( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="サーバ編-②nodejs"><a class="header" href="#サーバ編-②nodejs">サーバ編 ②（Node.js）</a></h1>
<h2 id="今回のゴール-1"><a class="header" href="#今回のゴール-1">今回のゴール</a></h2>
<ul>
<li>Supabase を用いたデータの永続化を実装する．</li>
<li>「todo リスト」を実装し，CRUD 処理とデータの構造を把握する．</li>
<li>Slack と連携する処理を実装する．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="データの永続化について"><a class="header" href="#データの永続化について">データの永続化について</a></h1>
<h2 id="nodejs-におけるデータ永続化"><a class="header" href="#nodejs-におけるデータ永続化">Node.js におけるデータ永続化</a></h2>
<p>データの永続化とは，アプリケーションの状態によらずデータを保持することである．言い換えると，DB などの外部にデータを保存すること．</p>
<p>データの永続化に使用する外部 DB は次のようなものがある．Node.js ではいずれの DB も利用できるが，RDB であれば MySQL か PostgreSQL，NoSQL では MongoDB，Firebase，Redis などがよく用いられる．</p>
<h2 id="rdb"><a class="header" href="#rdb">RDB</a></h2>
<p>SQL を用いてデータ管理を行う DB．柔軟な集計や結合ができ，情報も多い．</p>
<p>基本的には同じ SQL を記述すれば同じ動作が実行されるが，それぞれの DB で仕様が異なる部分もあるので使用前は要チェックすべし．</p>
<p>できることは非常に幅広く，データを扱う上でできないことはほぼないと考えて良い．</p>
<h3 id="例"><a class="header" href="#例">例</a></h3>
<ul>
<li>MySQL</li>
<li>PostgreSQL</li>
<li>OracleDB</li>
</ul>
<h2 id="nosql"><a class="header" href="#nosql">NoSQL</a></h2>
<p>Not Only SQL．SQL を前提としたデータ構造に縛られない DB．「値」およびそれを取得するための「キー」だけを格納できる Key-Value 型の DB などが代表的だ．</p>
<p>下記の例においてもそれぞれデータ構造が異なるため，プロジェクトの目的に合致した DB を選択する必要がある．</p>
<p>RDB と比較して後発のためにより直感的に扱えるものが多い一方で，データの格納および取得が高度に最適化されているが故に，機能性を最小限にしているものもある．</p>
<ul>
<li>MongoDB</li>
<li>Firebase Firestore Database</li>
<li>Firebase Realtime Database</li>
<li>Redis</li>
<li>DynamoDB</li>
<li>Neo4j</li>
<li>Supabase</li>
</ul>
<h2 id="使い分け"><a class="header" href="#使い分け">使い分け</a></h2>
<p>ケースバイケース．</p>
<p>アプリケーションが実現したい機能を明確にし，相性が良い方を選択する．</p>
<h2 id="今回使用する-db"><a class="header" href="#今回使用する-db">今回使用する DB</a></h2>
<p><strong>今回は環境構築が不要でオンラインにデータを保存できる「Supabase」を使用する．</strong></p>
<p>GitHub アカウントで使用できる．特徴は以下のとおり．</p>
<ul>
<li>オンライン上にデータを保存できる．</li>
<li>DB の構成がテーブル管理であるため NoSQL の中では RDB に近く，SQL ライクな操作ができる．
<ul>
<li>PostgreSQL が元．</li>
</ul>
</li>
<li>DB 以外にも Auth，Storage など利用可能．</li>
<li>各種言語やフレームワーク用のライブラリが充実しており開発がしやすい（個人の感想）．</li>
</ul>
<p>ドキュメント</p>
<p><a href="https://supabase.com/docs">https://supabase.com/docs</a></p>
<p>注意点</p>
<ul>
<li>無料プランでは 1 週間で DB が止まる（管理画面から再起動可能）．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="supabase-の準備"><a class="header" href="#supabase-の準備">Supabase の準備</a></h1>
<h2 id="supabase-の準備-1"><a class="header" href="#supabase-の準備-1">Supabase の準備</a></h2>
<p>今回は NoSQL である Supabase を用いて CRUD 処理を実装してみる．</p>
<p>DB がオンライン上にあるので，環境問わず使えるところが魅力．</p>
<h2 id="db-の作成"><a class="header" href="#db-の作成">DB の作成</a></h2>
<h3 id="プロジェクト作成-1"><a class="header" href="#プロジェクト作成-1">プロジェクト作成</a></h3>
<p>Supabase のコンソール（<a href="https://app.supabase.io/">https://app.supabase.io/</a>）にアクセスし，GitHub アカウントでサインインする．</p>
<p>「New project」をクリックし，project を作成する．
<img src="api-02/./img/supabase-01.png" alt="Supabaseプロジェクト作成" /></p>
<p>プロジェクト名と DB アクセス用パスワードを設定する．面倒なパスワードを作成しないといけないので注意．</p>
<p><img src="api-02/./img/supabase-02.png" alt="Supabaseプロジェクト詳細" /></p>
<h3 id="テーブルの作成"><a class="header" href="#テーブルの作成">テーブルの作成</a></h3>
<p>「Create a new table」をクリックし，テーブルを作成する．</p>
<p>テーブル名：<code>todo_table</code></p>
<p>カラム：以下のとおり設定</p>
<table><thead><tr><th>Name</th><th>Type</th><th>備考</th></tr></thead><tbody>
<tr><td><code>id</code></td><td><code>int8</code></td><td>初期設定のまま</td></tr>
<tr><td><code>user_id</code></td><td><code>int8</code></td><td>追加</td></tr>
<tr><td><code>todo</code></td><td><code>varchar</code></td><td>追加</td></tr>
<tr><td><code>deadline</code></td><td><code>date</code></td><td>追加</td></tr>
<tr><td><code>is_done</code></td><td><code>bool</code></td><td>初期値は <code>false</code></td></tr>
<tr><td><code>created_at</code></td><td><code>timestampz</code></td><td>初期設定のまま</td></tr>
<tr><td><code>updated_at</code></td><td><code>timestampz</code></td><td><code>created-at</code> と同様</td></tr>
</tbody></table>
<h2 id="nodejs-と-supabase-の連携"><a class="header" href="#nodejs-と-supabase-の連携">Node.js と Supabase の連携</a></h2>
<ol>
<li>Supabase の管理画面から「<code>⚙</code>」→「<code>API</code>」の順にクリックする．</li>
<li><code>Project API keys</code> と <code>Config</code> の <code>URL</code> が必要になるので確認する．</li>
</ol>
<p><img src="api-02/./img/supabase-03.png" alt="Supabaseアクセス情報" /></p>
<ol start="3">
<li>プロジェクト直下に <code>.env</code> ファイルを作成し，以下の内容を記述する．これらの情報は機密情報なので環境変数を用いて管理する．</li>
</ol>
<pre><code class="language-txt">SUPABASE_URL=`2で確認したURL`
SUPABASE_API_KEY=`2で確認したAPI key`
</code></pre>
<ol start="4">
<li>以下のコマンドを実行し，環境変数を使用するためのライブラリをインストールする．</li>
</ol>
<pre><code class="language-bash">$ npm i dotenv
</code></pre>
<ol start="5">
<li><code>.gitignore</code> に以下の内容を追記し，<code>.env</code> ファイルを Git 管理外にする．</li>
</ol>
<pre><code>/node_modules

# 🔽 ここを追記
.env
</code></pre>
<ol start="6">
<li>下記コマンドを実行し，Node.js から Supabase を扱うためのライブラリをインストールする．</li>
</ol>
<pre><code class="language-bash">$ npm i @supabase/supabase-js
</code></pre>
<p>ここまででアプリケーションと Supabase を連携させる準備は完了．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ファイル作成と動作確認"><a class="header" href="#ファイル作成と動作確認">ファイル作成と動作確認</a></h1>
<h2 id="ルーティング表"><a class="header" href="#ルーティング表">ルーティング表</a></h2>
<p>これから実装していく機能は以下のとおり．基本的な CRUD 処理を実装する．</p>
<table><thead><tr><th>URI</th><th>method</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>/todo</code></td><td>GET</td><td>findAll</td><td>データ全件取得</td></tr>
<tr><td><code>/todo/today</code></td><td>GET</td><td>find</td><td>本日締切のデータ取得</td></tr>
<tr><td><code>/todo</code></td><td>POST</td><td>store</td><td>データ作成処理</td></tr>
<tr><td><code>/todo/:id</code></td><td>PUT</td><td>update</td><td>データ更新処理</td></tr>
<tr><td><code>/todo/:id</code></td><td>DELETE</td><td>destroy</td><td>データ削除処理</td></tr>
</tbody></table>
<h2 id="役割分担"><a class="header" href="#役割分担">役割分担</a></h2>
<p>前回講義の役割分担表も参照．今回は repository に DB 関連の処理を実装する．</p>
<p>repository に DB 関連の処理を任せることで，DB が変更された場合でも他のコードの影響せずに運用することができる．このような役割分担をリポジトリパターンと呼ぶ．</p>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>routes</td><td>URI と実行する処理の対応．</td></tr>
<tr><td>controllers</td><td>リクエストパラメータの検証，レスポンス送信．</td></tr>
<tr><td>services</td><td>リクエストに対する処理のメインロジックを記述．</td></tr>
<tr><td>repositories</td><td>DB 関連の処理を記述．今回は Supabase とやり取りする処理を記述する．</td></tr>
</tbody></table>
<h2 id="既存ファイルへの追記と新規ファイルの準備"><a class="header" href="#既存ファイルへの追記と新規ファイルの準備">既存ファイルへの追記と新規ファイルの準備</a></h2>
<p><code>app.js</code>にルーティングを追記する．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
import { omikujiRouter } from &quot;./routes/omikuji.route.js&quot;;
import { jankenRouter } from &quot;./routes/janken.route.js&quot;;
// 🔽 追加
import { todoRouter } from &quot;./routes/todo.route.js&quot;;

const app = express();
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
const port = 3000;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));
app.use(&quot;/janken&quot;, (req, res) =&gt; jankenRouter(req, res));

// 🔽 追加
app.use(&quot;/todo&quot;, (req, res) =&gt; todoRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});
</code></pre>
<h2 id="必要なファイルの作成"><a class="header" href="#必要なファイルの作成">必要なファイルの作成</a></h2>
<p>新しく以下のファイルを作成する．前回の役割に加えて，今回は DB 関連の処理が必要となるため <code>repositories</code> フォルダを作成してファイルを追加する．</p>
<ul>
<li><code>routes/todo.route.js</code></li>
<li><code>controllers/todo.controller.js</code></li>
<li><code>services/todo.service.js</code></li>
<li><code>repositories/todo.repository.js</code></li>
</ul>
<p>まずそれぞれのファイルが連携できることを確認するため，DB と接続せずに固定のデータを返す処理を実装する．</p>
<h2 id="ルーティングの作成"><a class="header" href="#ルーティングの作成">ルーティングの作成</a></h2>
<p>まずはルーティングを作成．</p>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
import { readAllTodoData } from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成"><a class="header" href="#コントローラの作成">コントローラの作成</a></h2>
<p>コントローラではリクエストとレスポンスを定義．</p>
<pre><code class="language-js">// controllers/todo.controller.js

import { getAllTodoData } from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  try {
    const result = await getAllTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully get All Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成"><a class="header" href="#サービスの作成">サービスの作成</a></h2>
<p>サービスではリポジトリの関数（<code>findAll()</code>）を呼び出す．</p>
<pre><code class="language-js">// services/todo.service.js

import { findAll } from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  try {
    return await findAll();
  } catch (e) {
    throw Error(&quot;Error while getting All Todo Data&quot;);
  }
};
</code></pre>
<h2 id="リポジトリの作成"><a class="header" href="#リポジトリの作成">リポジトリの作成</a></h2>
<p>リポジトリは一旦決まったメッセージを返す．</p>
<pre><code class="language-js">// repositories/todo.repository.js

export const findAll = () =&gt; {
  return { message: &quot;OK&quot; };
};
</code></pre>
<h2 id="動作確認-4"><a class="header" href="#動作確認-4">動作確認</a></h2>
<p>動作確認する．以下のコマンドでレスポンスが返ってくれば OK．</p>
<pre><code class="language-bash">$ curl localhost:3000/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;message&quot;: &quot;OK&quot;
  },
  &quot;message&quot;: &quot;Successfully get All Todo Data!&quot;
}

</code></pre>
<p>一通りの動作が確認できたら，続いて Supabase の CRUD 処理を作成していく．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-の処理"><a class="header" href="#create-の処理">Create の処理</a></h1>
<h2 id="create-処理の流れ"><a class="header" href="#create-処理の流れ">Create 処理の流れ</a></h2>
<p>はじめは Create の処理を実装する．クライアントから送信されたデータを DB に保存する一連の流れを書く．</p>
<p>今回は<code>POST</code>メソッドでデータを送信し，新規レコードを作成する．</p>
<h2 id="ルーティングの作成-1"><a class="header" href="#ルーティングの作成-1">ルーティングの作成</a></h2>
<p>ルーティングでは，collection 名とデータを受け取り，コントローラにデータを渡す．</p>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
// 🔽 編集
import {
  readAllTodoData,
  createTodoData,
} from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
// 🔽 追加
todoRouter.post(&quot;/&quot;, (req, res) =&gt; createTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-1"><a class="header" href="#コントローラの作成-1">コントローラの作成</a></h2>
<p>コントローラでは，データを整理してサービスに渡す．また，サービスの処理結果を元にレスポンスを返す．</p>
<pre><code class="language-js">// controllers/todo.controller.js

// 🔽 編集
import { getAllTodoData, insertTodoData } from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  // 省略
};

// 🔽 追加
export const createTodoData = async (req, res, next) =&gt; {
  try {
    const { todo, deadline, user_id } = req.body;
    if (!(todo &amp;&amp; deadline &amp;&amp; user_id)) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await insertTodoData({
      params: { todo: todo, deadline: deadline, user_id: Number(user_id) },
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully post Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成-1"><a class="header" href="#サービスの作成-1">サービスの作成</a></h2>
<p>サービスではロジックが必要な場合は記述するが，今回はデータをそのまま渡すだけ．実際に Supabase にデータを保存する処理は <code>repositories</code> レイヤーに分割する．</p>
<pre><code class="language-js">// services/todo.service.js

// 🔽 編集
import { findAll, store } from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  // 省略
};

// 🔽 追加
export const insertTodoData = async ({ params }) =&gt; {
  try {
    return await store({ params });
  } catch (e) {
    throw Error(&quot;Error while posting Todo Data&quot;);
  }
};
</code></pre>
<h2 id="リポジトリの作成-1"><a class="header" href="#リポジトリの作成-1">リポジトリの作成</a></h2>
<p>テーブルを指定してデータを保存する処理を実装する．ここで Supabase 関連のコードを記述する必要があるため，関連するコードを import する．</p>
<p>データ永続化に関するコードをリポジトリのレイヤーに閉じ込めることで，DB の種類が変更された場合にもコントローラやサービスのコードに影響ない状態にすることができる．</p>
<p>ポイントは以下のとおり．</p>
<ul>
<li><code>dotenv</code> で環境変数を読み込む．</li>
<li><code>createClient</code> で Supabase との連携を確立する．</li>
<li><code>insert()</code> でデータを作成する．</li>
<li><code>created_at</code>と<code>updated_at</code>は Supabase 側で初期値（現在日時）を設定しているため投稿不要．</li>
</ul>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/insert">https://supabase.com/docs/reference/javascript/insert</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

export const findAll = () =&gt; {
  return { message: &quot;OK&quot; };
};

export const store = async ({ params }) =&gt; {
  try {
    const { data, error } = await supabase.from(&quot;todo_table&quot;).insert([
      {
        ...params,
        is_done: false,
      },
    ]);
    return data;
  } catch (e) {
    throw Error(&quot;Error while store Todo Data&quot;);
  }
};
</code></pre>
<h2 id="動作確認-5"><a class="header" href="#動作確認-5">動作確認</a></h2>
<p>処理を追加したら動作確認する．サーバを起動して下記コマンドでデータを送信し，成功のレスポンスが返ってくれば OK．</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;todo&quot;:&quot;node.js&quot;,&quot;user_id&quot;:1,&quot;deadline&quot;:&quot;2021-12-31&quot;}' localhost:3000/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-31&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully post Todo Data!&quot;
}

</code></pre>
<p>また，ブラウザで Supabase のコンソール画面からテーブルにアクセスし，送信したデータが保存されていることを確認しておく．</p>
<p>動作が確認できたら，2-3 件データを入れておこう．<strong>日付は本日含め適当に設定して複数件入れておく．</strong></p>
<p><img src="api-02/./img/supabase-04.png" alt="Supabase データ保存確認" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="read-の処理全件"><a class="header" href="#read-の処理全件">Read の処理（全件）</a></h1>
<h2 id="データ全件取得の処理"><a class="header" href="#データ全件取得の処理">データ全件取得の処理</a></h2>
<p>Read の処理では，ルーティングとコントローラとサービスははじめにつくったものを使用する．</p>
<p>リポジトリに以下の内容を記述する．テーブルを指定してデータをすべて取得する．<code>order()</code> を使用してデータを並び替えることができる．</p>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/using-modifiers">https://supabase.com/docs/reference/javascript/using-modifiers</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

// 🔽 編集
export const findAll = async () =&gt; {
  try {
    const { data, error } = await supabase
      .from(&quot;todo_table&quot;)
      .select()
      .order(&quot;deadline&quot;, { ascending: true })
      .order(&quot;todo&quot;, { ascending: true });
    return data;
  } catch (e) {
    throw Error(&quot;Error while getting Todo Data&quot;);
  }
};

export const store = async ({ params }) =&gt; {
  // 省略
};
</code></pre>
<h2 id="動作確認全件取得"><a class="header" href="#動作確認全件取得">動作確認（全件取得）</a></h2>
<p>記述したら動作確認する．下記コマンドを実行して，保存されているデータが全件取得できれば OK（下記はデータ 2 件登録時の例）．</p>
<pre><code class="language-bash">$ curl localhost:3000/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 2,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;react&quot;,
      &quot;deadline&quot;: &quot;2021-12-21&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-16T06:23:58.614838+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:23:58.614838+00:00&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-31&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully get All Todo Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="read-の処理本日以前"><a class="header" href="#read-の処理本日以前">Read の処理（本日以前）</a></h1>
<h2 id="本日締切のデータだけを取得する処理"><a class="header" href="#本日締切のデータだけを取得する処理">本日締切のデータだけを取得する処理</a></h2>
<p>前項でデータを全件取得する処理を実装したので，次は条件をつけてデータを取得する処理を実装する．</p>
<p><code>deadline</code> カラムの値を参照し，「実行した日と同じかそれ以前」のデータのみ取得する．</p>
<h2 id="ルーティングの作成-2"><a class="header" href="#ルーティングの作成-2">ルーティングの作成</a></h2>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
// 🔽 編集
import {
  readAllTodoData,
  readTodayTodoData,
  createTodoData,
} from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
// 🔽 追加
todoRouter.get(&quot;/today&quot;, (req, res) =&gt; readTodayTodoData(req, res));
todoRouter.post(&quot;/&quot;, (req, res) =&gt; createTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-2"><a class="header" href="#コントローラの作成-2">コントローラの作成</a></h2>
<p>URL に付加した id を<code>req.params.id</code>で取得する．サービスに id を渡す．</p>
<pre><code class="language-js">// controllers/todo.controller.js

import {
  getAllTodoData,
  getTodayTodoData,
  insertTodoData,
} from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  // 省略
};

// 🔽 追加
export const readTodayTodoData = async (req, res, next) =&gt; {
  try {
    const result = await getTodayTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully get Today Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

export const createTodoData = async (req, res, next) =&gt; {
  // 省略
};
</code></pre>
<h2 id="サービスの作成-2"><a class="header" href="#サービスの作成-2">サービスの作成</a></h2>
<p>今回は特にロジックなし．</p>
<pre><code class="language-js">// services/todo.service.js

import { findAll, findToday, store } from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  // 省略
};

// 🔽 追加
export const getTodayTodoData = async () =&gt; {
  try {
    return await findToday();
  } catch (e) {
    throw Error(&quot;Error while getting Today Todo Data&quot;);
  }
};

export const insertTodoData = async ({ params }) =&gt; {
  // 省略
};
</code></pre>
<h2 id="リポジトリの作成-2"><a class="header" href="#リポジトリの作成-2">リポジトリの作成</a></h2>
<p><code>deadline</code> のカラムで条件を指定する．</p>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/using-filters">https://supabase.com/docs/reference/javascript/using-filters</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

export const findAll = async () =&gt; {
  // 省略
};

// 🔽 追加
export const findToday = async () =&gt; {
  try {
    const { data, error } = await supabase
      .from(&quot;todo_table&quot;)
      .select()
      .lte(&quot;deadline&quot;, new Date().toISOString())
      .order(&quot;deadline&quot;, { ascending: true })
      .order(&quot;todo&quot;, { ascending: true });
    return data;
  } catch (e) {
    throw Error(&quot;Error while getting Todo Data&quot;);
  }
};

export const store = async ({ params }) =&gt; {
  // 省略
};
</code></pre>
<h2 id="動作確認1-件取得"><a class="header" href="#動作確認1-件取得">動作確認（1 件取得）</a></h2>
<p>下記コマンドで動作をチェック．<code>deadline</code> が実行した日以前のデータが取得できれば OK．</p>
<pre><code class="language-bash">$ curl localhost:3000/todo/today

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 7,
      &quot;user_id&quot;: 2,
      &quot;todo&quot;: &quot;react&quot;,
      &quot;deadline&quot;: &quot;2021-12-04&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-06T06:31:13.794412+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-06T06:31:13.794412+00:00&quot;
    },
    {
      &quot;id&quot;: 6,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-06&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-06T06:30:24.275881+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-06T06:30:24.275881+00:00&quot;
    },
    {
      &quot;id&quot;: 1,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;test&quot;,
      &quot;deadline&quot;: &quot;2021-12-06&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-06T06:26:57.344976+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-06T06:26:57.344976+00:00&quot;
    },
    {
      &quot;id&quot;: 8,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;zoom meeting&quot;,
      &quot;deadline&quot;: &quot;2021-12-07&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-07T04:16:41.726675+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-07T04:16:41.726675+00:00&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;user_id&quot;: 2,
      &quot;todo&quot;: &quot;Nest.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-15&quot;,
      &quot;is_done&quot;: true,
      &quot;created_at&quot;: &quot;2021-12-06T06:27:33.388245+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-06T08:27:11.024+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully get Today Todo Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="update-の処理"><a class="header" href="#update-の処理">Update の処理</a></h1>
<h2 id="データ更新の処理"><a class="header" href="#データ更新の処理">データ更新の処理</a></h2>
<p>既存のデータを上書きする処理を実装する．<code>PUT</code> 形式でデータを送信する．</p>
<blockquote>
<p><strong>Key Point</strong>💡</p>
<p><code>PUT</code> 形式は <code>GET</code> と <code>POST</code> が合わさったような形式で，<code>req.params.id</code> で id を送信し，同時に <code>req.body</code> で上書きするデータを送信する．</p>
<p>今回は使用しないが，<code>GET</code> でも同様に <code>req.params.id</code> で id を送信して受け取ることができる．</p>
</blockquote>
<h2 id="ルーティングの作成-3"><a class="header" href="#ルーティングの作成-3">ルーティングの作成</a></h2>
<p>update のルーティングを追加．</p>
<p>id 指定する．<code>/hoge</code> に <code>PUT</code> でリクエストを送信した場合，<code>req.params.id</code> は<code>hoge</code>になる．</p>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
// 🔽 編集
import {
  readAllTodoData,
  readTodayTodoData,
  createTodoData,
  editTodoData,
} from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
todoRouter.get(&quot;/today&quot;, (req, res) =&gt; readTodayTodoData(req, res));
todoRouter.post(&quot;/&quot;, (req, res) =&gt; createTodoData(req, res));
// 🔽 追加
todoRouter.put(&quot;/:id&quot;, (req, res) =&gt; editTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-3"><a class="header" href="#コントローラの作成-3">コントローラの作成</a></h2>
<p>コントローラでは，リクエストから <code>更新対象のドキュメントのid</code> と <code>更新データ</code> の 2 つを受け取る．送信されたデータの中から，これら 2 つのデータを抽出し，サービスに渡す．</p>
<pre><code class="language-js">// controllers/todo.controller.js

// 🔽 編集
import {
  getAllTodoData,
  getTodayTodoData,
  insertTodoData,
  updateTodoData,
} from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  //  省略
};

export const readTodayTodoData = async (req, res, next) =&gt; {
  // 省略
};

export const createTodoData = async (req, res, next) =&gt; {
  // 省略
};

// 🔽 追加
export const editTodoData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    const { user_id, todo, deadline, is_done } = req.body;
    if (
      !(
        id &amp;&amp;
        user_id &amp;&amp;
        todo &amp;&amp;
        deadline &amp;&amp;
        ![null, undefined].includes(is_done)
      )
    ) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await updateTodoData({
      id: id,
      params: {
        user_id: user_id,
        todo: todo,
        deadline: deadline,
        is_done: is_done,
      },
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully edit Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成-3"><a class="header" href="#サービスの作成-3">サービスの作成</a></h2>
<p>送信されたデータを渡すのみなのでこれまでの処理と同様．</p>
<pre><code class="language-js">// services/todo.service.js

import {
  findAll,
  findToday,
  store,
  update,
} from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  // 省略
};

export const getTodayTodoData = async () =&gt; {
  // 省略
};

export const insertTodoData = async ({ params }) =&gt; {
  // 省略
};

// 🔽 追加
export const updateTodoData = async ({ id, params }) =&gt; {
  try {
    return await update({ id, params });
  } catch (e) {
    throw Error(&quot;Error while updating Todo Data&quot;);
  }
};
</code></pre>
<h2 id="リポジトリの作成-3"><a class="header" href="#リポジトリの作成-3">リポジトリの作成</a></h2>
<p>リポジトリでは，受け取ったデータで DB を更新する．同時に <code>updated_at</code> に実行日時を設定して送信する．</p>
<p><code>update()</code> メソッドが用意されているのでこれを使用すれば OK．</p>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/update">https://supabase.com/docs/reference/javascript/update</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

export const findAll = async () =&gt; {
  // 省略
};

export const findToday = async () =&gt; {
  // 省略
};

export const store = async ({ params }) =&gt; {
  // 省略
};

// 🔽 追加
export const update = async ({ id, params }) =&gt; {
  try {
    const { data, error } = await supabase
      .from(&quot;todo_table&quot;)
      .update({ ...params, updated_at: new Date().toISOString() })
      .match({ id: id });
    return data;
  } catch (e) {
    throw Error(&quot;Error while updating Todo Data&quot;);
  }
};
</code></pre>
<h2 id="動作確認更新"><a class="header" href="#動作確認更新">動作確認（更新）</a></h2>
<p>動作確認する．更新前に適当なデータを確認し，更新状態が確認できるようにしておこう．</p>
<p>コンソール画面 or 前項の Read 処理でデータを確認し，データが更新されていれば OK！</p>
<pre><code class="language-bash">$ curl -X PUT -H &quot;Content-Type: application/json&quot; -d '{&quot;todo&quot;:&quot;Nest.js&quot;,&quot;user_id&quot;:2,&quot;deadline&quot;:&quot;2021-12-20&quot;,&quot;is_done&quot;:true}' localhost:3000/todo/2

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 2,
      &quot;user_id&quot;: 2,
      &quot;todo&quot;: &quot;Nest.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-20&quot;,
      &quot;is_done&quot;: true,
      &quot;created_at&quot;: &quot;2021-12-06T06:27:33.388245+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:56:33.618+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully edit Todo Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="delete-の処理"><a class="header" href="#delete-の処理">Delete の処理</a></h1>
<h2 id="データ削除の処理"><a class="header" href="#データ削除の処理">データ削除の処理</a></h2>
<p>id を指定して該当するデータを DB から削除する．テーブルと id を指定すれば OK．</p>
<h2 id="ルーティングの作成-4"><a class="header" href="#ルーティングの作成-4">ルーティングの作成</a></h2>
<p>削除のルーティングを追加．更新の場合と同様にパラメータを受け取る．</p>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
// 🔽 編集
import {
  readAllTodoData,
  readTodayTodoData,
  createTodoData,
  editTodoData,
  deleteTodoData,
} from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
todoRouter.get(&quot;/today&quot;, (req, res) =&gt; readTodayTodoData(req, res));
todoRouter.post(&quot;/&quot;, (req, res) =&gt; createTodoData(req, res));
todoRouter.put(&quot;/:id&quot;, (req, res) =&gt; editTodoData(req, res));
// 🔽 追加
todoRouter.delete(&quot;/:id&quot;, (req, res) =&gt; deleteTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-4"><a class="header" href="#コントローラの作成-4">コントローラの作成</a></h2>
<p>コントローラでは id を受け取り，サービスの処理を実行する．</p>
<pre><code class="language-js">// controllers/todo.controller.js

// 🔽 編集
import {
  getAllTodoData,
  getTodayTodoData,
  insertTodoData,
  updateTodoData,
  destroyTodoData,
} from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  // 省略
};

export const readTodayTodoData = async (req, res, next) =&gt; {
  // 省略
};

export const createTodoData = async (req, res, next) =&gt; {
  // 省略
};

export const editTodoData = async (req, res, next) =&gt; {
  // 省略
};

// 🔽 追加
export const deleteTodoData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    if (!id) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await destroyTodoData({
      id: id,
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully delete Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成-4"><a class="header" href="#サービスの作成-4">サービスの作成</a></h2>
<p>サービスでは id 指定してリポジトリで定義した関数を実行する．</p>
<pre><code class="language-js">// services/todo.service.js

// 🔽 編集
import {
  findAll,
  findToday,
  store,
  update,
  destroy,
} from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  // 省略
};

export const getTodayTodoData = async () =&gt; {
  // 省略
};

export const insertTodoData = async ({ params }) =&gt; {
  // 省略
};

export const updateTodoData = async ({ id, params }) =&gt; {
  // 省略
};

// 🔽 追加
export const destroyTodoData = async ({ id }) =&gt; {
  try {
    return await destroy({ id: id });
  } catch (e) {
    throw Error(&quot;Error while deleting Todo Data&quot;);
  }
};
</code></pre>
<h2 id="リポジトリの作成-4"><a class="header" href="#リポジトリの作成-4">リポジトリの作成</a></h2>
<p>リポジトリでは DB からデータを削除する．id があればデータを指定して削除することができる．</p>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/delete">https://supabase.com/docs/reference/javascript/delete</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

export const findAll = async () =&gt; {
  // 省略
};

export const findToday = async () =&gt; {
  // 省略
};

export const store = async ({ params }) =&gt; {
  // 省略
};

export const update = async ({ id, params }) =&gt; {
  // 省略
};

// 🔽 追加
export const destroy = async ({ id }) =&gt; {
  try {
    const { data, error } = await supabase
      .from(&quot;todo_table&quot;)
      .delete()
      .match({ id: id });
    return data;
  } catch (e) {
    throw Error(&quot;Error while deleting Todo Data&quot;);
  }
};
</code></pre>
<h2 id="動作確認削除"><a class="header" href="#動作確認削除">動作確認（削除）</a></h2>
<p>動作確認する．document 名 は既存のデータから適当に指定する．</p>
<p>コンソール画面 or 前項の Read 処理でデータを確認し，データが削除されていれば OK！</p>
<pre><code class="language-bash">$ curl -X DELETE localhost:3000/todo/13

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 13,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-31&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully delete Todo Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="slack-連携設定"><a class="header" href="#slack-連携設定">Slack 連携設定</a></h1>
<p>本項（と次の項）では，Slack で bot を作成し，todo の内容を投稿してもらう処理を実装する．</p>
<h3 id="step-1"><a class="header" href="#step-1">STEP 1</a></h3>
<p>まずは，以下 2 つのエンドポイントを作成して手動で実行する処理をつくる．</p>
<ul>
<li>todo リスト全件のデータを取得して Slack に投稿する．</li>
<li>実行日以前のデータのみ取得して Slack に投稿する．</li>
</ul>
<h3 id="step-2"><a class="header" href="#step-2">STEP 2</a></h3>
<p>上記の処理を利用し，指定した時間で定期実行するように処理を拡張する．</p>
<h2 id="slack-と連携するための設定"><a class="header" href="#slack-と連携するための設定">Slack と連携するための設定</a></h2>
<p>下記 URL にアクセスする．</p>
<p><a href="https://api.slack.com/">https://api.slack.com/</a></p>
<p><code>Create an app</code> をクリック．</p>
<p><img src="api-02/./img/slack-setup-01.png" alt="" /></p>
<p><code>From scratch</code> を選択．</p>
<p><img src="api-02/./img/slack-setup-02.png" alt="" /></p>
<p>「アプリ名（任意）」と「使用するワークスペース」を選択して <code>Create App</code> をクリック．</p>
<p><img src="api-02/./img/slack-setup-03.png" alt="" /></p>
<p>画面が変わるので，左側のメニューから <code>OAuth &amp; Permissions</code> → <code>Scopes</code> 部分の <code>Bot Token Scopes</code> を <code>chat:write</code> に設定する．</p>
<p><img src="api-02/./img/slack-setup-04.png" alt="" /></p>
<p><code>Install Workspace</code> がクリックできるようになっているのでクリックする．画面が変わったら <code>Allow</code> をクリック．</p>
<p><img src="api-02/./img/slack-setup-05.png" alt="" /></p>
<p><img src="api-02/./img/slack-setup-06.png" alt="" /></p>
<p>画面が変わるので <code>Bot User Access Token</code> をメモしておく．</p>
<p><img src="api-02/./img/slack-setup-07.png" alt="" /></p>
<p>Slack アプリ側で Bot を追加したい channel で「右上のメンバーボタン」→「Integrations」→ <code>Add an App</code> の順に進む．</p>
<p><img src="api-02/./img/slack-setup-08.png" alt="" /></p>
<p>作成したアプリ部分の <code>Add</code> ボタンをクリックする．</p>
<p><img src="api-02/./img/slack-setup-09.png" alt="" /></p>
<p>これでアプリ側の設定は完了．</p>
<h2 id="token-を環境変数に設定"><a class="header" href="#token-を環境変数に設定">Token を環境変数に設定</a></h2>
<p><code>.env</code> ファイルに <code>Bot User Access Token</code> を記述しておく．</p>
<pre><code class="language-txt">SUPABASE_URL=https://hogehoge.supabase.co
SUPABASE_API_KEY=hogefugapiyofoobar.eyJyb2xlIjoiYW5vbiIsImlhdCI6MTYzODc3MDU0NCwiZXhwIjoxOTU0MzQ2NTQ0fQ.FM4MwMd8wbPDGbXtnGfsn6bGSgMzBLdHOMGWRwhoK2I

SLACK_API_TOKEN=`取得した Bot User OAuth Token`
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="slack-連携実装"><a class="header" href="#slack-連携実装">Slack 連携実装</a></h1>
<p>最終的には定期実行になるが，まずは手動で動作させるため API を作成しておく．</p>
<p>（フロントにもテスト画面を実装して手動実行させられるようにしたい）</p>
<h2 id="準備"><a class="header" href="#準備">準備</a></h2>
<p>Node.js から Slack へ投稿するためにライブラリをインストールする．</p>
<pre><code class="language-bash">$ npm i @slack/web-api
</code></pre>
<p>また，Slack 連携の処理を実装するため，下記ファイルを作成しておく．</p>
<ul>
<li><code>routes/slack.route.js</code></li>
<li><code>controllers/slack.controller.js</code></li>
<li><code>services/slack.service.js</code></li>
</ul>
<p><code>app.js</code> を以下のように編集する．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
import { omikujiRouter } from &quot;./routes/omikuji.route.js&quot;;
import { jankenRouter } from &quot;./routes/janken.route.js&quot;;
import { todoRouter } from &quot;./routes/todo.route.js&quot;;
// 🔽 追加
import { slackRouter } from &quot;./routes/slack.route.js&quot;;

const app = express();
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));
app.use(&quot;/janken&quot;, (req, res) =&gt; jankenRouter(req, res));
app.use(&quot;/todo&quot;, (req, res) =&gt; todoRouter(req, res));
// 🔽 追加
app.use(&quot;/slack&quot;, (req, res) =&gt; slackRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});
</code></pre>
<h2 id="ルーティングの作成-5"><a class="header" href="#ルーティングの作成-5">ルーティングの作成</a></h2>
<p>エンドポイントは 2 つ作成する．</p>
<ul>
<li><code>slack/</code> で todo リスト全件を Slack 投稿．</li>
<li><code>slack/today</code> で本日以前締切のデータのみを Slack 投稿．</li>
</ul>
<pre><code class="language-js">// routes/slack.route.js

import express from &quot;express&quot;;
import {
  sendAllTodoData,
  sendTodayTodoData,
} from &quot;../controllers/slack.controller.js&quot;;

export const slackRouter = express.Router();

slackRouter.get(&quot;/&quot;, (req, res) =&gt; sendAllTodoData(req, res));
slackRouter.get(&quot;/today&quot;, (req, res) =&gt; sendTodayTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-5"><a class="header" href="#コントローラの作成-5">コントローラの作成</a></h2>
<p>サービスの処理を呼び出しつつ，レスポンスを設定．</p>
<pre><code class="language-js">// controllers/slack.controller.js

import {
  postAllTodoData,
  postTodayTodoData,
} from &quot;../services/slack.service.js&quot;;

export const sendAllTodoData = async (req, res, next) =&gt; {
  try {
    const result = await postAllTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully send All Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

export const sendTodayTodoData = async (req, res, next) =&gt; {
  try {
    const result = await postTodayTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully send Today Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成-5"><a class="header" href="#サービスの作成-5">サービスの作成</a></h2>
<p>メインのロジックを記述する．</p>
<p>Slack 連携のライブラリを読み込み，投稿の処理を実装する．</p>
<ul>
<li>
<p><code>postToSlack()</code> では <code>client.chat.postMessage</code> を使用し，任意の channel に任意のテキストを投稿している．</p>
</li>
<li>
<p><code>postAllTodoData()</code> では前項で実装した <code>findAll()</code> メソッドで全件データを取得し，<code>postToSlack()</code> メソッドで投稿を行う．</p>
</li>
<li>
<p><code>postTodayTodoData()</code> では前項で実装した <code>findToday()</code> メソッドで全件データを取得し，<code>postToSlack()</code> メソッドで投稿を行う．</p>
</li>
<li>
<p>（投稿のテキストはいい感じに作りましょう w）</p>
</li>
</ul>
<pre><code class="language-js">// services/slack.service.js

import { findAll, findToday } from &quot;../repositories/todo.repository.js&quot;;
import { WebClient } from &quot;@slack/web-api&quot;;
import dotenv from &quot;dotenv&quot;;

dotenv.config();

const postToSlack = async (token, channel, text) =&gt; {
  const client = new WebClient(token);
  const response = await client.chat.postMessage({ channel, text });
  console.log(response.ok);
  return response;
};

export const postAllTodoData = async () =&gt; {
  try {
    const token = process.env.SLACK_API_TOKEN;
    const todoData = await findAll();
    const text = todoData.map((x) =&gt; `${x.deadline}\t${x.todo}`).join(&quot;\n&quot;);
    return await postToSlack(token, &quot;#test&quot;, `現在のTodo！\n${text}`);
  } catch (e) {
    throw Error(&quot;Error while posting All Todo Data&quot;);
  }
};

export const postTodayTodoData = async () =&gt; {
  try {
    const token = process.env.SLACK_API_TOKEN;
    const todoData = await findToday();
    const text = todoData.map((x) =&gt; `${x.deadline}\t${x.todo}`).join(&quot;\n&quot;);
    return await postToSlack(token, &quot;#test&quot;, `本日締切！！\n${text}`);
  } catch (e) {
    throw Error(&quot;Error while posting Today Todo Data&quot;);
  }
};
</code></pre>
<h2 id="動作確認手動"><a class="header" href="#動作確認手動">動作確認（手動）</a></h2>
<p>設定したエンドポイントにリクエストを送って Slack に投稿されることを確認！</p>
<h3 id="全件投稿"><a class="header" href="#全件投稿">全件投稿</a></h3>
<pre><code class="language-bash">$ curl http://localhost:3000/slack

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;ok&quot;: true,
    &quot;channel&quot;: &quot;C01EF7W0YF3&quot;,
    &quot;ts&quot;: &quot;1639641376.000100&quot;,
    &quot;message&quot;: {
      &quot;bot_id&quot;: &quot;B01EF806CV7&quot;,
      &quot;type&quot;: &quot;message&quot;,
      &quot;text&quot;: &quot;現在のTodo！\n2021-12-04\treact\n2021-12-06\tnode.js\n2021-12-06\ttest\n2021-12-07\tzoom meeting\n2021-12-20\tNext.js\n2021-12-31\tnode.js\n2021-12-31\tnode.js\n2021-12-31\tnode.js\n2021-12-31\tnode.js\n2021-12-31\ttest&quot;,
      &quot;user&quot;: &quot;U01ESE8S9NU&quot;,
      &quot;ts&quot;: &quot;1639641376.000100&quot;,
      &quot;team&quot;: &quot;T4GCXGMGQ&quot;,
      &quot;bot_profile&quot;: {
        &quot;id&quot;: &quot;B01EF806CV7&quot;,
        &quot;app_id&quot;: &quot;A01E8PJTS04&quot;,
        &quot;name&quot;: &quot;cat-commander&quot;,
        &quot;icons&quot;: {
          &quot;image_36&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_36.png&quot;,
          &quot;image_48&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_48.png&quot;,
          &quot;image_72&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_72.png&quot;
        },
        &quot;deleted&quot;: false,
        &quot;updated&quot;: 1638887573,
        &quot;team_id&quot;: &quot;T4GCXGMGQ&quot;
      }
    },
    &quot;response_metadata&quot;: {
      &quot;scopes&quot;: [
        &quot;chat:write&quot;
      ],
      &quot;acceptedScopes&quot;: [
        &quot;chat:write&quot;
      ]
    }
  },
  &quot;message&quot;: &quot;Successfully send All Todo Data!&quot;
}
</code></pre>
<h3 id="実行日以前の締切のみ投稿"><a class="header" href="#実行日以前の締切のみ投稿">実行日以前の締切のみ投稿</a></h3>
<pre><code class="language-bash">$ curl http://localhost:3000/slack/today

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;ok&quot;: true,
    &quot;channel&quot;: &quot;C01EF7W0YF3&quot;,
    &quot;ts&quot;: &quot;1639641433.000200&quot;,
    &quot;message&quot;: {
      &quot;bot_id&quot;: &quot;B01EF806CV7&quot;,
      &quot;type&quot;: &quot;message&quot;,
      &quot;text&quot;: &quot;本日締切！！\n2021-12-04\treact\n2021-12-06\tnode.js\n2021-12-06\ttest\n2021-12-07\tzoom meeting&quot;,
      &quot;user&quot;: &quot;U01ESE8S9NU&quot;,
      &quot;ts&quot;: &quot;1639641433.000200&quot;,
      &quot;team&quot;: &quot;T4GCXGMGQ&quot;,
      &quot;bot_profile&quot;: {
        &quot;id&quot;: &quot;B01EF806CV7&quot;,
        &quot;app_id&quot;: &quot;A01E8PJTS04&quot;,
        &quot;name&quot;: &quot;cat-commander&quot;,
        &quot;icons&quot;: {
          &quot;image_36&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_36.png&quot;,
          &quot;image_48&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_48.png&quot;,
          &quot;image_72&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_72.png&quot;
        },
        &quot;deleted&quot;: false,
        &quot;updated&quot;: 1638887573,
        &quot;team_id&quot;: &quot;T4GCXGMGQ&quot;
      }
    },
    &quot;response_metadata&quot;: {
      &quot;scopes&quot;: [
        &quot;chat:write&quot;
      ],
      &quot;acceptedScopes&quot;: [
        &quot;chat:write&quot;
      ]
    }
  },
  &quot;message&quot;: &quot;Successfully send Today Todo Data!&quot;
}

</code></pre>
<h2 id="定期実行の設定"><a class="header" href="#定期実行の設定">定期実行の設定</a></h2>
<p>手動で投稿する実装が完了したら，時間を指定して定期実行する処理を実装する．</p>
<p>定期実行には <code>node-cron</code> ライブラリを用いる．</p>
<ul>
<li>
<p>時間を指定しておくと自動で任意の処理を実行してくれる．</p>
</li>
<li>
<p>時間指定には 6 つの数値を用いる．順番が決まっており，以下の通りである．</p>
</li>
</ul>
<pre><code class="language-txt"> # ┌────────────── second (optional)
 # │ ┌──────────── minute
 # │ │ ┌────────── hour
 # │ │ │ ┌──────── day of month
 # │ │ │ │ ┌────── month
 # │ │ │ │ │ ┌──── day of week
 # │ │ │ │ │ │
 # │ │ │ │ │ │
 # * * * * * *

</code></pre>
<p>参考：<a href="https://github.com/node-cron/node-cron">https://github.com/node-cron/node-cron</a></p>
<h3 id="ライブラリのインストール"><a class="header" href="#ライブラリのインストール">ライブラリのインストール</a></h3>
<p>下記コマンドを実行してライブラリをインストールする．</p>
<pre><code class="language-bash">$ npm i node-cron
</code></pre>
<h3 id="定期実行の処理を追記"><a class="header" href="#定期実行の処理を追記">定期実行の処理を追記</a></h3>
<p>サービスの処理でライブラリを読み込み，定期実行の処理を追記する．</p>
<pre><code class="language-js">// services/slack.service.js

import { findAll, findToday } from &quot;../repositories/todo.repository.js&quot;;
import { WebClient } from &quot;@slack/web-api&quot;;
import dotenv from &quot;dotenv&quot;;
// 🔽 追加
import cron from &quot;node-cron&quot;;

dotenv.config();

const postToSlack = async (token, channel, text) =&gt; {
  // 省略
};

export const postAllTodoData = async () =&gt; {
  // 省略
};

export const postTodayTodoData = async () =&gt; {
  // 省略
};

// 例：日時設定せずに 3 秒毎に実行
// cron.schedule('*/3 * * * * *', () =&gt; console.log('3秒ごとに実行'));

// 例：毎日 19 時 30 分 30 秒と 19 時 30 分 40 秒に実行
cron.schedule(&quot;30 30 19 * * *&quot;, () =&gt; postAllTodoData());
cron.schedule(&quot;40 30 19 * * *&quot;, () =&gt; postTodayTodoData());
</code></pre>
<h2 id="動作確認定期実行"><a class="header" href="#動作確認定期実行">動作確認（定期実行）</a></h2>
<p>指定した時間に slack に投稿が行われれば OK！</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h1>
<p>今回は Node.js におけるデータの永続化を扱った．DB は Supabase を用いたが，他の DB でも処理の手順は大凡同様である．</p>
<p>今回はリポジトリパターンの実装で DB 関連の処理を別のレイヤーに切り出した．このようにすることで，DB 変更時にもコードの修正を該当レイヤーのみに閉じ込めることができる．</p>
<p>slack との連携では連携のための設定と，todo アプリケーションの内容を投稿する処理を実装した．投稿自体はそれほど難しい処理ではないため，他の処理と組み合わせることで様々なアプリケーションを実装できるだろう．</p>
<p>今回は以上である( `･ω･´)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="フロント編-①react"><a class="header" href="#フロント編-①react">フロント編 ①（React）</a></h1>
<h2 id="今回のゴール-2"><a class="header" href="#今回のゴール-2">今回のゴール</a></h2>
<ul>
<li>
<p>React の基本的な処理を知り，実装を行う．</p>
</li>
<li>
<p>コンポーネントの組み合わせやデータの受け渡しを理解する．</p>
</li>
<li>
<p>外部との通信を実装し，データの扱い方や注意点を理解する．</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="react-とは"><a class="header" href="#react-とは">React とは</a></h1>
<ul>
<li>ユーザインターフェース構築のための JavaScript ライブラリ</li>
</ul>
<h2 id="宣言的な-view"><a class="header" href="#宣言的な-view">宣言的な View</a></h2>
<ul>
<li>
<p>React は、インタラクティブなユーザインターフェイスの作成にともなう苦痛を取り除きます．アプリケーションの各状態に対応するシンプルな View を設計するだけで，React はデータの変更を検知し，関連するコンポーネントだけを効率的に更新，描画します．</p>
</li>
<li>
<p>宣言的な View を用いてアプリケーションを構築することで，コードはより見通しが立ちやすく，デバッグのしやすいものになります．</p>
</li>
</ul>
<h2 id="コンポーネントベース"><a class="header" href="#コンポーネントベース">コンポーネントベース</a></h2>
<ul>
<li>
<p>自分自身の状態を管理するカプセル化されたコンポーネントをまず作成し，これらを組み合わせることで複雑なユーザインターフェイスを構築します．</p>
</li>
<li>
<p>コンポーネントのロジックは，Template ではなく JavaScript そのもので書くことができるので，様々なデータをアプリケーション内で簡単に取り回すことができ，かつ DOM に状態を持たせないようにすることができます．</p>
</li>
</ul>
<h2 id="一度学習すればどこでも使える"><a class="header" href="#一度学習すればどこでも使える">一度学習すれば、どこでも使える</a></h2>
<ul>
<li>
<p>React と組み合わせて使用する技術に制限はありません．React を使って新しい機能を追加する際に，既存のソースコードを書き換える必要はありません．</p>
</li>
<li>
<p>React は Node を使ったサーバー上でもレンダーできますし，React Native を使うことでモバイルアプリケーションの中でも動きます．</p>
</li>
</ul>
<h2 id="で結局なんなのじゃ"><a class="header" href="#で結局なんなのじゃ">で，結局なんなのじゃ？</a></h2>
<ul>
<li>
<p>描画などの面倒な処理をいい感じにやってくれる．</p>
</li>
<li>
<p>画面に表示したいパーツ（コンポーネント）ごとに記述するので他の部分に影響しづらく，使い回しが効く．</p>
</li>
<li>
<p>ライブラリが充実しているのでだいたいのことはわりと簡単にできる．</p>
</li>
</ul>
<h2 id="今回作成するアプリケーション"><a class="header" href="#今回作成するアプリケーション">今回作成するアプリケーション</a></h2>
<ul>
<li>
<p>オススメ本を表示する SPA．</p>
</li>
<li>
<p>ページごとにカテゴリ別の本が一覧で表示される．</p>
</li>
<li>
<p>本のデータ Google books API から読み込んで表示する．</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="アプリケーション実装の準備"><a class="header" href="#アプリケーション実装の準備">アプリケーション実装の準備</a></h1>
<h2 id="必要なツールのバージョン確認"><a class="header" href="#必要なツールのバージョン確認">必要なツールのバージョン確認</a></h2>
<ul>
<li>Node.js と npm が必要なので，以下のコマンドで状況を確認する．</li>
<li>バージョンが表示されれば OK．</li>
</ul>
<pre><code class="language-bash">$ node -v
v16.13.0
$ npm -v
8.1.0

</code></pre>
<h2 id="プロジェクトの作成"><a class="header" href="#プロジェクトの作成">プロジェクトの作成</a></h2>
<ul>
<li>
<p>React はプロジェクト単位でアプリケーションを開発する．</p>
</li>
<li>
<p>専用のコマンドが用意されているので，以下のようにプロジェクトを作成する．</p>
</li>
<li>
<p><code>npx</code> を使用すると，インストールしていないパッケージを実行できる．グローバルに残らないので，汚染の心配がない．</p>
</li>
<li>
<p>最後の <code>react-app</code> はプロジェクト名なので好きな名前で OK．</p>
</li>
</ul>
<pre><code class="language-bash">$ npx create-react-app react-app
</code></pre>
<p>※<code>npm</code> ではなく <code>npx</code> である点に注意！</p>
<p>いい感じにできたら，以下のコマンドでディレクトリに移動し，サーバを起動する．</p>
<pre><code class="language-bash">$ cd react-app
$ npm start
</code></pre>
<p>自動的にブラウザが立ち上がり，以下のような画面が表示されれば OK．</p>
<p><img src="app-01/./img/firstview.png" alt="初期画面の画像" /></p>
<p>サーバはターミナル上で <code>control + c</code> すると停止できる．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>React の開発手順について</p>
<ul>
<li>
<p><code>npm start</code> を実行した状態でファイルを編集すると自動的にコンパイルが行われ，最新の状態がブラウザ画面に反映される．</p>
</li>
<li>
<p><code>npm start</code> 実行 -&gt; vs code でコード編集 -&gt; ブラウザで動作確認 の繰り返し．</p>
</li>
<li>
<p>ライブラリ追加時などはサーバを再起動しないと反映されないため．動作しない場合は <code>control + c</code> して再度 <code>npm start</code> でサーバを起動する．</p>
</li>
</ul>
</blockquote>
<h2 id="react-の大まかな仕組み"><a class="header" href="#react-の大まかな仕組み">React の大まかな仕組み</a></h2>
<ul>
<li>
<p>アプリケーションは全て <code>public/index.html</code> 上で実行される．</p>
</li>
<li>
<p>実行時には <code>src/index.js</code> が実行され，<code>App</code> コンポーネントが <code>index.html</code> 上にマウントされる．</p>
</li>
<li>
<p>実際に画面に表示されるのは <code>App.js</code> 内に記述された内容となる．</p>
</li>
<li>
<p>この <code>App.js</code> から様々なコンポーネントを読み込むことでアプリケーションが動作する．</p>
</li>
</ul>
<h2 id="メイン画面の編集と不要なファイルの削除"><a class="header" href="#メイン画面の編集と不要なファイルの削除">メイン画面の編集と不要なファイルの削除</a></h2>
<p>メインの画面は <code>App.js</code> であり，このファイルが <code>index.html</code> の <code>id=root</code> に描画される．</p>
<p>初期状態では <code>App.js</code> に不要な記述が含まれているため削除する．合わせて使用しないファイルも削除する．</p>
<p><code>App.js</code> のファイル名を <code>App.jsx</code> に変更し，内容を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>以下のファイルを削除する．</p>
<ul>
<li>
<p><code>src/App.css</code></p>
</li>
<li>
<p><code>src/App.test.js</code></p>
</li>
<li>
<p><code>src/logo.svg</code></p>
</li>
</ul>
<p>また，<code>index.js</code> の内容を以下のように編集する．</p>
<pre><code class="language-js">// index.js

import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import App from &quot;./App&quot;;
import reportWebVitals from &quot;./reportWebVitals&quot;;

ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById(&quot;root&quot;)
);

reportWebVitals();
</code></pre>
<p>以下のコマンドで開発サーバを起動する．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<p>ブラウザ画面を確認すると以下のようになっている．
<img src="app-01/./img/mainview01.png" alt="メイン画面1" /></p>
<blockquote>
<p>【補足】js と jsx</p>
<ul>
<li>
<p>js：Javascript のファイル．</p>
</li>
<li>
<p>jsx：React 要素を生成する Javascript の拡張．React ではこちらを使うとたくさんいいことがある．</p>
</li>
</ul>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コンポーネント"><a class="header" href="#コンポーネント">コンポーネント</a></h1>
<p>ここから，実際にコンポーネントを実装してみる．</p>
<p>まずは必要なファイルを準備しよう．</p>
<ul>
<li>
<p><code>src</code> ディレクトリに <code>components</code> ディレクトリを作成する．</p>
</li>
<li>
<p><code>components</code> ディレクトリ内に <code>Booklist.jsx</code> を作成する．</p>
</li>
<li>
<p><code>Booklist.jsx</code> に以下の内容を記述する．</p>
</li>
</ul>
<pre><code class="language-jsx">// Booklist.jsx

export const Booklist = (props) =&gt; {
  return (
    &lt;&gt;
      &lt;p&gt;this is book list component&lt;/p&gt;
    &lt;/&gt;
  );
};
</code></pre>
<blockquote>
<p>【解説】コンポーネントの作成</p>
<ul>
<li>
<p>コンポーネントには「class コンポーネント」と「関数コンポーネント」の 2 種類が存在する．</p>
</li>
<li>
<p>class コンポーネントは「状態を持つことができる（ステートフル）」という特徴があるが，関数コンポーネントでは「状態を持つことができない（ステートレス）」．</p>
</li>
<li>
<p>しかし，関数コンポーネントでも「React hooks」という技術を使うことで同様の振る舞いを実現することができる．</p>
</li>
<li>
<p>「state」というのはコンポーネント自体が持つ値であり，他にコンポーネントが外から受け取る「props」が存在する．</p>
</li>
<li>
<p>コンポーネント作成の際には，できるだけ state を持たないよう設計すると動作確認が楽になるだけでなく，バグの生まれる可能性も低減できる．</p>
</li>
<li>
<p>そのため，本記事ではすべて関数コンポーネントを使用してアプリケーションを構築し，必要に応じて「React hooks」を使用して状態を管理する．</p>
</li>
</ul>
</blockquote>
<h2 id="コンポーネントの構造"><a class="header" href="#コンポーネントの構造">コンポーネントの構造</a></h2>
<ul>
<li>
<p>関数 <code>Booklist</code> は呼び出し元のコンポーネントから<code>props</code>を受け取り，html 要素を出力する．</p>
</li>
<li>
<p><code>export const Booklist = ...</code> とすることで，他のコンポーネントから <code>import { Booklist } ...</code> のように記述して呼び出せるようにしている．</p>
</li>
</ul>
<h2 id="コンポーネントの呼び出し1"><a class="header" href="#コンポーネントの呼び出し1">コンポーネントの呼び出し（1）</a></h2>
<p><code>Booklist</code> コンポーネントを作成したので，<code>App</code> コンポーネントから呼び出してみる．</p>
<p><code>App.jsx</code> を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

// 🔽 追加（App.jsx 内で使用するためにコンポーネントを呼び出す）
import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>ブラウザで表示を確認すると以下のようになっている．</p>
<p><img src="app-01/./img/mainview02.png" alt="メイン画面2" /></p>
<p>また，検証画面を確認すると，以下のように Booklist コンポーネントが読み込まれていることがわかる．</p>
<p><img src="app-01/./img/elements01.png" alt="検証画面1" /></p>
<h2 id="コンポーネントの呼び出し2"><a class="header" href="#コンポーネントの呼び出し2">コンポーネントの呼び出し（2）</a></h2>
<p>呼び出すコンポーネントを 2 つにしてみる．</p>
<p><code>App.jsx</code> を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  return (
    // 🔽 編集
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist /&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>ブラウザ画面で，<code>Booklist</code> コンポーネントが 2 つ表示されていることを確認しよう．</p>
<p>このように，作成したコンポーネントは複数使用することもできる．</p>
<p><img src="app-01/./img/mainview03.png" alt="メイン画面3" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="props-の活用"><a class="header" href="#props-の活用">props の活用</a></h1>
<p><code>props</code> は呼び出し元のコンポーネント（親コンポーネント）から呼び出されたコンポーネント（子コンポーネント）に渡されるデータの塊である．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>React のコンポーネントは「関数」であり，入力と出力がある．「入力」に当たるのがこの <code>props</code> である．</p>
</blockquote>
<h2 id="props-でデータを渡す"><a class="header" href="#props-でデータを渡す"><code>props</code> でデータを渡す</a></h2>
<p>実際に <code>App</code> コンポーネントから <code>Booklist</code> コンポーネントに文字列のデータを渡してみよう．</p>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    // 🔽 編集（コンポーネントに props を設定）
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist language={languages[0]} /&gt;
      &lt;Booklist /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>ここでは，「<code>App</code> コンポーネントから <code>Booklist</code> コンポーネントに」「<code>language</code> という名前で」「<code>languages[0]</code> の値」を渡している．</p>
<p>タグ内に変数を入れるときは <code>{}</code> を使用する．</p>
<h2 id="props-でデータを受け取る"><a class="header" href="#props-でデータを受け取る"><code>props</code> でデータを受け取る</a></h2>
<p>続いて，値を渡される <code>Booklist.jsx</code> を以下のように編集する．</p>
<pre><code class="language-jsx">// Booklist.jsx

export const Booklist = ({ language }) =&gt; {
  return (
    &lt;&gt;
      &lt;p&gt;this is {language} list component&lt;/p&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>ブラウザで画面を確認すると以下のような状態になる．</p>
<p>1 つめのコンポーネントは <code>React</code> の文字列が追加されているが，2 つめのコンポーネントには追加されていない．なぜだろうか．</p>
<p><img src="app-01/./img/mainview04.png" alt="メイン画面4" /></p>
<p>1 つめのコンポーネントには <code>App.jsx</code> で <code>language={languages[0]}</code> が記述されているが，2 つめでは記述されていない．そのため，2 つめのコンポーネントでは <code>props</code> が空の状態となっており表示が追加されない．</p>
<h2 id="追加"><a class="header" href="#追加">追加！</a></h2>
<p>2 つめのコンポーネントにもデータを渡すには次のように <code>App.jsx</code> を編集する．</p>
<p>（ついでにコンポーネントを追加！）</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    // 🔽 編集（コンポーネントに props を設定）
    &lt;&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Booklist language={languages[0]} /&gt;
      &lt;Booklist language={languages[1]} /&gt;
      &lt;Booklist language={languages[2]} /&gt;
    &lt;/&gt;
  );
};
export default App;
</code></pre>
<p>こうなる！</p>
<p><img src="app-01/./img/mainview05.png" alt="メイン画面5" /></p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>このように，関数コンポーネントは <code>props</code> を受け取り，要素を返す関数となる．実装するときは「何を入力して」「何を出力するのか」を意識すると（多分）混乱せずすすめることができる．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="router-機能"><a class="header" href="#router-機能">router 機能</a></h1>
<p>実際の web アプリケーションでは，処理ごとにページを分けて行いたい場合が多い．</p>
<p>ここまでの実装では，1 つのページに全てのコンポーネントを表示していたが，本項ではコンポーネントを別ページで表現する．そのままの記述ではページ遷移が行えないので，新しく <code>react-router</code> のライブラリをインストールする．</p>
<h2 id="react-router-のインストール"><a class="header" href="#react-router-のインストール"><code>react-router</code> のインストール</a></h2>
<p>ターミナルで<strong>作業ディレクトリにいることを確認</strong>し，下記コマンドを実行する．</p>
<pre><code class="language-bash">$ npm install react-router-dom
</code></pre>
<blockquote>
<p>【解説】ルーティング</p>
<ul>
<li>
<p>通常，React で web アプリケーションを実装すると，コンポーネントが切り替わっても URL は変化しない．</p>
</li>
<li>
<p>この 2 つを関連づけて，URL からアプリ内の特定のコンポーネントにアクセスできるようにしたり，逆にアプリ内での状態変化を URL に反映させたりすることをルーティングと呼ぶ．</p>
</li>
<li>
<p>ルーティングしておくと，ブラウザの戻るボタンで戻ったり，URL を打って特定のページに直接アクセスできたりするのでいい感じになる．</p>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>【注意】</strong></p>
<p><code>react-router</code> はバージョンが 5 から 6 にアップデートされたタイミングで記述方法が変更された部分がある．ドキュメントはバージョン 6 のものを確認すること．</p>
</blockquote>
<h2 id="ルーティングの定義"><a class="header" href="#ルーティングの定義">ルーティングの定義</a></h2>
<p><code>react-router</code>の機能を用いてルーティングを実装する．</p>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

import Booklist from &quot;./components/Booklist&quot;;
// 🔽 追加
import { BrowserRouter, Routes, Route } from &quot;react-router-dom&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    // 🔽 編集
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/react&quot; element={&lt;Booklist language={languages[0]} /&gt;} /&gt;
        &lt;Route path=&quot;/vue&quot; element={&lt;Booklist language={languages[1]} /&gt;} /&gt;
        &lt;Route path=&quot;/angular&quot; element={&lt;Booklist language={languages[2]} /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<ul>
<li>
<p><code>&lt;BrowserRouter&gt;</code> の中に <code>&lt;Routes&gt;</code> と <code>&lt;Route&gt;</code> を置き，<code>path</code> に対応させたい URL を，<code>element</code> に描画したいコンポーネントを渡す．</p>
</li>
<li>
<p><code>element</code> 内にコンポーネントを記述した場合でも <code>props</code> の渡し方は同様である．</p>
</li>
</ul>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>router 機能を使用したい場合は，コンポーネントを必ず <code>&lt;BrowserRouter&gt;</code> 内に配置すること．</p>
</blockquote>
<p>ブラウザで<code>localhost:3000/vue</code>などと URL を入力して表示を確認しよう．</p>
<p><img src="app-01/./img/mainview06.png" alt="メイン画面6" /></p>
<h2 id="リンクを貼る"><a class="header" href="#リンクを貼る">リンクを貼る</a></h2>
<ul>
<li>
<p>毎回 URL 入力はダルい．</p>
</li>
<li>
<p>せっかくルーティングを実装したので，リンクを張ってブラウザ上で移動できるようにしたい．</p>
</li>
<li>
<p><code>react-router</code> の <code>Link</code> 機能を使うと簡単にリンクを作成できる．</p>
</li>
</ul>
<p><code>App.jsx</code>を以下のように編集する．</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;
// 🔽 Link を追加
import { BrowserRouter, Routes, Route, Link } from &quot;react-router-dom&quot;;

const App = () =&gt; {
  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];

  return (
    // 🔽 編集
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/react&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/react&quot; element={&lt;Booklist language={languages[0]} /&gt;} /&gt;
        &lt;Route path=&quot;/vue&quot; element={&lt;Booklist language={languages[1]} /&gt;} /&gt;
        &lt;Route path=&quot;/angular&quot; element={&lt;Booklist language={languages[2]} /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<p><code>&lt;Link&gt;</code> タグの <code>to</code> 部分に移動したい URL を書いておくと，<code>&lt;a&gt;</code> タグのようにリンクしてくれる．</p>
<p>ブラウザ画面で移動できることを確認しよう．</p>
<p><img src="app-01/./img/mainview07.png" alt="メイン画面7" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="子コンポーネントへの関数入力"><a class="header" href="#子コンポーネントへの関数入力">子コンポーネントへの関数入力</a></h1>
<p>ページごとにコンポーネントを表示できたので，それぞれのページでキーワードから本のデータを取得したい．</p>
<p>子コンポーネントで関数を定義してもよいが，今回は <code>App.jsx</code> で関数を定義して子コンポーネントに渡す（関数の渡し方の練習）．</p>
<h2 id="関数の定義を-props-の-1-つとして渡す"><a class="header" href="#関数の定義を-props-の-1-つとして渡す">関数の定義を <code>props</code> の 1 つとして渡す</a></h2>
<p><code>App.jsx</code> を以下のように編集する</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;
import { BrowserRouter, Routes, Route, Link } from &quot;react-router-dom&quot;;

const App = () =&gt; {
  // 🔽 関数を追加
  const getDataFromAPI = (keyword) =&gt; {
    return `${keyword} books`;
  };

  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    // 🔽 1つ目のコンポーネントに関数を渡す
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/react&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Routes&gt;
        &lt;Route
          path=&quot;/react&quot;
          element={
            &lt;Booklist language={languages[0]} getData={getDataFromAPI} /&gt;
          }
        /&gt;
        &lt;Route path=&quot;/vue&quot; element={&lt;Booklist language={languages[1]} /&gt;} /&gt;
        &lt;Route path=&quot;/angular&quot; element={&lt;Booklist language={languages[2]} /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<p>ここでは「<code>getData</code>」という名前で「keyword を入力すると <code>getDataFromApi(keyword)</code> を実行する関数」を「<code>Booklist</code> コンポーネント」に渡している．</p>
<h2 id="props-からの受け取りと関数の実行"><a class="header" href="#props-からの受け取りと関数の実行">props からの受け取りと関数の実行</a></h2>
<p>続いて，<code>Booklist</code> コンポーネントで関数を受け取って実行する．</p>
<p>子コンポーネントで，読み込み時に渡された関数を実行してその結果を要素に反映する．</p>
<pre><code class="language-jsx">// Booklist.jsx

// 🔽 propsを追加
export const Booklist = ({ language, getData }) =&gt; {
  // 🔽 関数を実行（`?` を使用することで，`getData` が存在する場合のみ関数を実行可能）
  const result = getData?.(language);

  return (
    &lt;&gt;
      &lt;p&gt;this is {result} list component&lt;/p&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>ブラウザで確認すると「react books」のように表示がされていることがわかる．<code>Vue</code> と <code>Angular</code> の部分は関数を渡していないので表示がされない状態で OK．</p>
<p><img src="app-01/./img/mainview08.png" alt="メイン画面8" /></p>
<p>ここまでうまく行ったら，<code>App.jsx</code> 内の <code>&lt;Route&gt;</code> 要素残り 2 つも同様に追記しよう．</p>
<pre><code class="language-jsx">// App.jsx

import { Booklist } from &quot;./components/Booklist&quot;;
import { BrowserRouter, Route, Link } from &quot;react-router-dom&quot;;

const App = () =&gt; {
  const getDataFromAPI = (keyword) =&gt; {
    return `${keyword} books`;
  };

  const languages = [&quot;React&quot;, &quot;Vue&quot;, &quot;Angular&quot;];
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;react app&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/react&quot;&gt;React&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/vue&quot;&gt;Vue&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/angular&quot;&gt;Angular&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Routes&gt;
        &lt;Route
          path=&quot;/react&quot;
          element={
            &lt;Booklist language={languages[0]} getData={getDataFromAPI} /&gt;
          }
        /&gt;
        &lt;Route
          path=&quot;/vue&quot;
          element={
            &lt;Booklist language={languages[1]} getData={getDataFromAPI} /&gt;
          }
        /&gt;
        &lt;Route
          path=&quot;/angular&quot;
          element={
            &lt;Booklist language={languages[2]} getData={getDataFromAPI} /&gt;
          }
        /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<p>ブラウザで操作し，うまくいけば OK．これで親コンポーネントで定義した関数を子コンポーネントに渡すことができた．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-リクエストの実装"><a class="header" href="#http-リクエストの実装">http リクエストの実装</a></h1>
<ul>
<li>子コンポーネントに関数が渡せたが，現状では入力値に文字列を追加して出力するだけの関数である．</li>
<li>そこで，指定したキーワードで Google books API からデータを取得する処理に変更する．</li>
<li>http リクエストには<code>axios</code>を使用する．</li>
</ul>
<h2 id="axios-ライブラリのインストール"><a class="header" href="#axios-ライブラリのインストール">axios ライブラリのインストール</a></h2>
<p>下記コマンドでインストール．</p>
<pre><code class="language-bash">$ npm install axios
</code></pre>
<p>エラーがでなければ OK．</p>
<h2 id="リクエスト関数を実装"><a class="header" href="#リクエスト関数を実装">リクエスト関数を実装</a></h2>
<p><code>App.jsx</code> の <code>getDataFromAPI</code> 関数を編集する．</p>
<pre><code class="language-jsx">// App.jsx

// 🔽 追加
import axios from &quot;axios&quot;;

// ...省略

// 🔽 getDataFromAPI 関数の内容を編集
const getDataFromAPI = async (keyword) =&gt; {
  const requestUrl = &quot;https://www.googleapis.com/books/v1/volumes?q=intitle:&quot;;
  const result = await axios.get(`${requestUrl}${keyword}`);
  return result;
};

// ...省略
</code></pre>
<p>※この記述だけでは動きません！！</p>
<h2 id="コンポーネントで関数を実行するusestate-useeffect"><a class="header" href="#コンポーネントで関数を実行するusestate-useeffect">コンポーネントで関数を実行する（useState, useEffect）</a></h2>
<p>子コンポーネントで <code>getDataFromAPI</code> 関数を実行したいが，以下 2 つの問題がある．</p>
<ul>
<li>子コンポーネントは関数であるため，取得したデータを保持できない．</li>
<li>データ更新時にレンダリングが再実行されるため，API リクエストが無限ループになる．</li>
</ul>
<p>前者の問題には <code>useState</code>，後者の問題には <code>useEffect</code> という機能を使うことで対処できる．</p>
<p>（<code>useState</code> と <code>useEffect</code> は React の標準の機能なのでインストールなどの作業は必要ない）</p>
<p><code>Booklist.jsx</code>を下記のように編集する．</p>
<pre><code class="language-jsx">// Booklist.jsx

// 🔽 追加
import { useState, useEffect } from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {
  // 🔽 ここから追加
  const [bookData, setBookData] = useState(null);

  useEffect(() =&gt; {
    const result = getData?.(language).then((response) =&gt;
      setBookData(response)
    );
  }, [language, getData]);

  // 🔼 ここまで追加

  return (
    &lt;&gt;
      &lt;p&gt;this is {JSON.stringify(bookData)} list component&lt;/p&gt;
    &lt;/&gt;
  );
};
</code></pre>
<p>ブラウザで確認すると，以下のように取得したデータが文字列で表示される．</p>
<p><img src="app-01/./img/mainview09.png" alt="メイン画面9" /></p>
<h2 id="解説usestate"><a class="header" href="#解説usestate">【解説】useState</a></h2>
<ul>
<li>
<p>useState は関数コンポーネントが値（今回は API から取得したデータ）を保持するための機能．</p>
</li>
<li>
<p><code>const [bookData, setBookData] = useState(null);</code> の</p>
<ul>
<li>
<p><code>bookData</code> がデータを保持するための変数名．</p>
</li>
<li>
<p><code>setBookData</code> がデータを更新するための関数．</p>
</li>
<li>
<p><code>useState(null)</code> の <code>null</code> が <code>bookData</code> の初期値．</p>
</li>
</ul>
</li>
<li>
<p><code>setBookData(最新の値)</code> のように記述することで， <code>bookData</code> の値が最新の値に更新される．</p>
</li>
<li>
<p><code>bookData</code> に保存した内容を表示したいときなどは通常の変数のように扱えば OK．</p>
</li>
</ul>
<h2 id="解説useeffect"><a class="header" href="#解説useeffect">【解説】useEffect</a></h2>
<ul>
<li>
<p>関数外の副作用（外部からのデータ取得や DOM の更新など）を扱うための機能．</p>
</li>
<li>
<p>React では，コンポーネント内でデータの更新があると再レンダリングされるため，API からデータを取得すると毎回レンダリングが発生して無限ループとなってしまう．</p>
</li>
<li>
<p>useEffect はレンダリングを制限し，特定の値が更新されたときのみ処理が実行されるようにしてくれる機能．</p>
</li>
<li>
<p>書式は以下のような感じ．</p>
</li>
</ul>
<pre><code class="language-jsx">useEffect(() =&gt; {
  実行したい処理
}, [ここに書いた値（今回は`language`と`getData`）が更新されたときのみ，上の{}内が実行される．ここに値を書くときは配列で書く]);
</code></pre>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p><code>useState</code> と <code>useEffect</code> 以外にも hooks には便利な機能が存在する．</p>
<p>まずはこの 2 つを使うことで多くの処理を実装可能であるため，まずはこの 2 つを扱えるようになろう．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="表示の調整"><a class="header" href="#表示の調整">表示の調整</a></h1>
<p>現状では取得したデータを全て文字列で表示しているだけなので，書籍のタイトルがリスト表示されるよう整える．</p>
<p>booksData から必要なデータを取り出して <code>map()</code> 関数で <code>&lt;li&gt;</code> タグをつくる．</p>
<pre><code class="language-jsx">// Booklist.jsx

import { useState, useEffect } from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {
  const [bookData, setBookData] = useState(null);

  useEffect(() =&gt; {
    const result = getData?.(language).then((response) =&gt;
      setBookData(response)
    );
  }, [language, getData]);

  // 🔽 データからタグを生成する処理を追加
  return (
    &lt;ul&gt;
      {bookData.data.items.map((x, index) =&gt; (
        &lt;li key={index}&gt;{x.volumeInfo.title}&lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<p>ブラウザで表示を確認するとエラーになる．</p>
<p><img src="app-01/./img/mainview10.png" alt="メイン画面10" /></p>
<blockquote>
<p>【補足】</p>
<p>現在の最新バージョンでは上記エラー画面が表示されない．コンソールにエラーメッセージが表示されるので，検証画面を確認しよう．</p>
</blockquote>
<p>このエラーの原因は，まだ API からデータを取得していない状態でレンダリングしようとして <code>map()</code> 関数が実行されているためである．<code>map()</code> 関数は配列に対して処理を行う関数だが，配列のデータが存在しない状態で実行しようとしているためエラーとなる．</p>
<p>三項演算子を使用して，<code>bookData</code> の有無で表示を切り替えることで回避できる．</p>
<ul>
<li>
<p><code>bookData</code> が <code>null</code> の場合はローディング中のメッセージを表示．</p>
</li>
<li>
<p>データが取得できたらリスト表示に切り替え．</p>
</li>
</ul>
<pre><code class="language-jsx">// Booklist.jsx

import { useState, useEffect } from &quot;react&quot;;

export const Booklist = ({ language, getData }) =&gt; {
  const [bookData, setBookData] = useState(null);

  useEffect(() =&gt; {
    const result = getData?.(language).then((response) =&gt;
      setBookData(response)
    );
  }, [language, getData]);

  return (
    &lt;ul&gt;
      {bookData === null ? (
        &lt;p&gt;now loading...&lt;/p&gt;
      ) : (
        bookData.data.items.map((x, index) =&gt; (
          &lt;li key={index}&gt;{x.volumeInfo.title}&lt;/li&gt;
        ))
      )}
    &lt;/ul&gt;
  );
};
</code></pre>
<p>このように表示されれば OK！</p>
<p><img src="app-01/./img/mainview11.png" alt="メイン画面11" /></p>
<p>リンククリックするとリストも切り替わる挙動になっている（はず）．</p>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>このように，React ではデータの取得とレンダリングのタイミングなどでハマることが多い．</p>
<p>まずはエラーをよく読むことと，目的のデータが存在しているかどうか，どんな形のデータになっているのかを確認しながら進めると良い．</p>
</blockquote>
<h2 id="参考"><a class="header" href="#参考">参考</a></h2>
<p>上記の問題は optional chaining でも回避可能．</p>
<pre><code class="language-jsx">&lt;ul&gt;
  {bookData?.data.items.map((x, index) =&gt; (
    &lt;li key={index}&gt;{x.volumeInfo.title}&lt;/li&gt;
  ))}
&lt;/ul&gt;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ-2"><a class="header" href="#まとめ-2">まとめ</a></h1>
<ul>
<li>
<p>React は関数である！</p>
</li>
<li>
<p>Props と State をマスターせよ！</p>
</li>
<li>
<p>useState と useEffect が扱えればプロダクトは実装できる！</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="課題-1"><a class="header" href="#課題-1">課題</a></h1>
<p>下記どちらかの実装に挑戦しよう．</p>
<p>成果物は GitHub の URL を Slack の指定したチャンネルに投稿すること．</p>
<ul>
<li>
<p>本のタイトル以外のデータ（著者や画像）の表示．</p>
</li>
<li>
<p>別の API を使用してデータをブラウザに表示．</p>
</li>
</ul>
<p>今回はここまで( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="フロント編-②react"><a class="header" href="#フロント編-②react">フロント編 ②（React）</a></h1>
<h2 id="今回のゴール-3"><a class="header" href="#今回のゴール-3">今回のゴール</a></h2>
<ul>
<li>
<p>前回実装したサーバアプリケーションのクライアント側を実装する．</p>
</li>
<li>
<p>コンポーネントの扱いを復習する．</p>
</li>
<li>
<p>データ取得タイミングと使い分けのイメージを把握する．</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="サーバ側の準備"><a class="header" href="#サーバ側の準備">サーバ側の準備</a></h1>
<p>サーバ側の処理は前回までに実装した内容そのままで問題ないが，クライアントからアクセスする場合に一部追加が必要になる．</p>
<h2 id="cross-origin-resource-sharing"><a class="header" href="#cross-origin-resource-sharing">Cross-Origin Resource Sharing</a></h2>
<p>サーバ側の規定の動作として「異なるオリジンからのアクセスをブロックする」というものが存在する．</p>
<pre><code class="language-txt">https://www.emperor-crimson.com
  ^       ^
  |       |
scheme hostname


http://localhost:5000
  ^       ^       ^
  |       |       |
scheme hostname  port

</code></pre>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p>実際の運用でサーバとクライアントを分ける場合には「サーバ側でクライアントのオリジンからのアクセスを許可する実装」が必要となる．</p>
<p>API へのリクエストを開放する場合にはリクエスト元のホスト問わず許可し，自分のアプリケーションからのみリクエストする場合はクライアント側のホスト名を指定しておく，など．</p>
</blockquote>
<h2 id="実装"><a class="header" href="#実装">実装</a></h2>
<p>Node.js では Cross-Origin を設定するためのライブラリが存在するので，これを利用するのが楽．</p>
<p>以下のコマンドでインストールする．</p>
<pre><code class="language-bash">$ npm i cors
</code></pre>
<p><code>app.js</code>に以下のように追記する．</p>
<p>今回は開発用として，リクエスト元を問わず受け付ける指定にしている．</p>
<p>より詳しい設定はドキュメントを参照．API 毎にアクセスを許可したり拒否したりできる．</p>
<p><a href="https://github.com/expressjs/cors">https://github.com/expressjs/cors</a></p>
<pre><code class="language-js">import express from &quot;express&quot;;
// 🔽 追加
import cors from &quot;cors&quot;;

// 省略

const app = express();
// 🔽 1 行追加
app.use(cors());
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// 省略
</code></pre>
<p><strong>クライアントからリクエストを受ける必要があるので，サーバ側のアプリケーションを立ち上げておこう．</strong></p>
<pre><code class="language-bash">$ npm start
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="必要な画面の準備"><a class="header" href="#必要な画面の準備">必要な画面の準備</a></h1>
<h2 id="ルーティング"><a class="header" href="#ルーティング">ルーティング</a></h2>
<p>クライアント側で必要な画面とパスは以下のとおり．フロント側のルーティングなのでサーバ側と混同しないように注意．</p>
<table><thead><tr><th>パス</th><th>画面の概要</th></tr></thead><tbody>
<tr><td><code>/todo/index</code></td><td>todo 一覧画面（全件）</td></tr>
<tr><td><code>/todo/today</code></td><td>todo 一覧画面（実行日以前締切）</td></tr>
<tr><td><code>/todo/post</code></td><td>todo 入力 &amp; 送信画面</td></tr>
</tbody></table>
<h2 id="必要なファイルの準備"><a class="header" href="#必要なファイルの準備">必要なファイルの準備</a></h2>
<ol>
<li>
<p><code>src</code>以下に<code>pages</code>フォルダを作成する．</p>
</li>
<li>
<p><code>pages</code>フォルダの中に下記のファイルを作成する．</p>
<ul>
<li>
<p><code>TodoIndex.jsx</code></p>
</li>
<li>
<p><code>TodoToday.jsx</code></p>
</li>
<li>
<p><code>TodoPost.jsx</code></p>
</li>
</ul>
</li>
</ol>
<p>ディレクトリは任意の構造にできるが，「ページを表すコンポーネント」と「部品としてのコンポーネント」を分けておくと管理しやすい．</p>
<p>それぞれ以下のように内容を記述する．</p>
<pre><code class="language-js">// src/pages/TodoIndex.jsx

export const TodoIndex = () =&gt; {
  return &lt;p&gt;todo （全件）一覧画面&lt;/p&gt;;
};
</code></pre>
<pre><code class="language-js">// src/pages/TodoToday.jsx

export const TodoToday = () =&gt; {
  return &lt;p&gt;todo （本日）一覧画面&lt;/p&gt;;
};
</code></pre>
<pre><code class="language-js">// src/pages/TodoPost.jsx

export const TodoPost = () =&gt; {
  return &lt;p&gt;todo 入力送信画面&lt;/p&gt;;
};
</code></pre>
<p><code>App.jsx</code>を以下のように編集する．</p>
<p>（これまでのコードは適宜コメントアウトしておくこと）</p>
<pre><code class="language-js">// src/App.jsx

import { BrowserRouter, Route, Link } from &quot;react-router-dom&quot;;
import { TodoIndex } from &quot;./pages/TodoIndex&quot;;
import { TodoToday } from &quot;./pages/TodoToday&quot;;
import { TodoPost } from &quot;./pages/TodoPost&quot;;

const NotFound = () =&gt; {
  return &lt;h2&gt;Not Found...&lt;/h2&gt;;
};

const App = () =&gt; {
  return (
    &lt;BrowserRouter&gt;
      &lt;h1&gt;Todoリストアプリケーション&lt;/h1&gt;
      &lt;ul&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/todo/index&quot;&gt;todo 一覧（全件）&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/todo/today&quot;&gt;todo 一覧（本日）&lt;/Link&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;Link to=&quot;/todo/post&quot;&gt;todo 入力&lt;/Link&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;hr /&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/todo/index&quot; element={&lt;TodoIndex /&gt;} /&gt;
        &lt;Route path=&quot;/todo/today&quot; element={&lt;TodoToday /&gt;} /&gt;
        &lt;Route path=&quot;/todo/post&quot; element={&lt;TodoPost /&gt;} /&gt;
        &lt;Route path=&quot;/*&quot; element={&lt;NotFound /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
};
export default App;
</code></pre>
<h2 id="動作確認-6"><a class="header" href="#動作確認-6">動作確認</a></h2>
<p>一通り記述したら画面の表示を確認する．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<p>それぞれの画面が表示されれば OK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="todo-送信画面の作成"><a class="header" href="#todo-送信画面の作成">todo 送信画面の作成</a></h1>
<p>ブラウザ画面から todo を送信できるように処理を追加する．</p>
<h2 id="form-を扱うライブラリの準備"><a class="header" href="#form-を扱うライブラリの準備">Form を扱うライブラリの準備</a></h2>
<p>前回の API と連携させるため，画面に入力したデータを POST で送信する必要がある（前回はターミナルでリクエストを送信していた）．</p>
<p>form を扱うのは面倒なのでライブラリを使用するのが得策．ちょうど <code>useState</code> や <code>useEffect</code> などの「Hooks」と合わせて使用できる「React Hook Form」が提供されている．</p>
<p><a href="https://react-hook-form.com/jp/">https://react-hook-form.com/jp/</a></p>
<p>下記コマンドでインストールする．</p>
<pre><code class="language-bash">$ npm i react-hook-form
</code></pre>
<p><code>TodoPost.jsx</code>を以下のように編集する．</p>
<p>まずは form の動きを確認する．</p>
<pre><code class="language-js">import { useState } from &quot;react&quot;;
import { useForm } from &quot;react-hook-form&quot;;
import axios from &quot;axios&quot;;

export const TodoPost = () =&gt; {
  const { register, handleSubmit } = useForm();

  const [formData, setFormData] = useState(null);

  const postFormData = async (postData) =&gt; {
    setFormData(JSON.stringify(postData));
  };

  return (
    &lt;form onSubmit={handleSubmit(postFormData)}&gt;
      &lt;input {...register(&quot;todo&quot;)} placeholder=&quot;Todo&quot; /&gt;
      &lt;input {...register(&quot;deadline&quot;)} placeholder=&quot;Deadline&quot; type=&quot;date&quot; /&gt;
      &lt;input {...register(&quot;user_id&quot;)} placeholder=&quot;User_id&quot; type=&quot;number&quot; /&gt;
      &lt;p&gt;{formData}&lt;/p&gt;
      &lt;button type=&quot;submit&quot;&gt;送信&lt;/button&gt;
    &lt;/form&gt;
  );
};
</code></pre>
<h2 id="動作確認-7"><a class="header" href="#動作確認-7">動作確認</a></h2>
<p>コードを記述したら動作を確認する．</p>
<p>入力欄に適当な文字列を入力し，入力した値が下記のように表示されれば OK．</p>
<pre><code class="language-txt">{&quot;todo&quot;:&quot;test&quot;,&quot;deadline&quot;:&quot;2022-02-22&quot;,&quot;user_id&quot;:&quot;4&quot;}
</code></pre>
<h2 id="post-送信処理の追加"><a class="header" href="#post-送信処理の追加">POST 送信処理の追加</a></h2>
<p>form の動きは確認できたので，サーバ側に入力内容を送信する．</p>
<p>POST で送信する場合は <code>axios.post()</code> を用いる．第 1 引数にリクエスト URL を，第 2 引数に送信するデータを入れる．</p>
<p><code>postFormData</code> 関数を以下のように編集する．</p>
<pre><code class="language-js">const postFormData = async (postData) =&gt; {
  setFormData(JSON.stringify(postData));
  const result = await axios.post(&quot;http://localhost:3001/todo&quot;, postData);
  console.log(result);
  return result;
};
</code></pre>
<h2 id="動作確認-8"><a class="header" href="#動作確認-8">動作確認</a></h2>
<blockquote>
<p>必ずサーバ側のアプリケーションを動作させてくこと！！</p>
</blockquote>
<p>先の動作確認と同様に，適当な文字列を入力欄に入力して送信する．</p>
<p>コンソールに以下のようなレスポンスが表示されれば OK．</p>
<pre><code class="language-js">{
  &quot;data&quot;: {
    &quot;status&quot;: 200,
    &quot;result&quot;: [
      {
        &quot;id&quot;:16,
        &quot;user_id&quot;:4,
        &quot;todo&quot;:&quot;test&quot;,
        &quot;deadline&quot;:&quot;2022-02-22&quot;,
        &quot;is_done&quot;:false,
        &quot;created_at&quot;:&quot;2022-02-04T09:54:00.949148+00:00&quot;,
        &quot;updated_at&quot;:&quot;2022-02-04T09:54:00.949148+00:00&quot;
      }
    ],
    &quot;message&quot;: &quot;Succesfully post Todo Data!&quot;
  },
  &quot;status&quot;: 200,
    &quot;statusText&quot;: &quot;OK&quot;,
      &quot;headers&quot;: {
    &quot;content-length&quot;: &quot;246&quot;,
      &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;
  },
  &quot;config&quot;: {
    &quot;url&quot;: &quot;http://localhost:3001/todo&quot;,
      &quot;method&quot;: &quot;post&quot;,
        &quot;data&quot;: &quot;{\&quot;todo\&quot;:\&quot;test\&quot;,\&quot;user_id\&quot;:\&quot;4\&quot;}&quot;,
          &quot;headers&quot;: {
      &quot;Accept&quot;: &quot;application/json, text/plain, */*&quot;,
        &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot;
    },
    &quot;transformRequest&quot;: [
      null
    ],
      &quot;transformResponse&quot;: [
        null
      ],
        &quot;timeout&quot;: 0,
          &quot;xsrfCookieName&quot;: &quot;XSRF-TOKEN&quot;,
            &quot;xsrfHeaderName&quot;: &quot;X-XSRF-TOKEN&quot;,
              &quot;maxContentLength&quot;: -1,
                &quot;maxBodyLength&quot;: -1
  },
  &quot;request&quot;: { }
}

</code></pre>
<p>これでブラウザから todo をサーバに送信する処理は完了．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="todo-一覧画面の作成"><a class="header" href="#todo-一覧画面の作成">todo 一覧画面の作成</a></h1>
<p>続いて一覧画面を作成する．</p>
<h2 id="ダミーデータの表示"><a class="header" href="#ダミーデータの表示">ダミーデータの表示</a></h2>
<p><code>TodoIndex.jsx</code> を以下のように編集する．</p>
<p>まずは適当なダミーデータを正しく画面に表示できることを確認する．ダミーデータを <code>useState</code> の変数に初期値として設定し，画面に表示する．</p>
<pre><code class="language-js">// src/pages/TodoIndex.jsx

import { useState } from &quot;react&quot;;

export const TodoIndex = () =&gt; {
  const dummyTodoList = [
    {
      id: 1,
      todo: &quot;test1&quot;,
      deadline: &quot;2022-02-02&quot;,
      user_id: &quot;1&quot;,
      id_done: false,
      created_at: JSON.stringify(new Date()),
      updated_at: JSON.stringify(new Date()),
    },
    {
      id: 2,
      todo: &quot;test2&quot;,
      deadline: &quot;2022-02-22&quot;,
      user_id: &quot;2&quot;,
      id_done: false,
      created_at: JSON.stringify(new Date()),
      updated_at: JSON.stringify(new Date()),
    },
    {
      id: 3,
      todo: &quot;test3&quot;,
      deadline: &quot;2022-02-28&quot;,
      user_id: &quot;3&quot;,
      id_done: false,
      created_at: JSON.stringify(new Date()),
      updated_at: JSON.stringify(new Date()),
    },
  ];

  const [todoList, setTodoList] = useState(dummyTodoList);

  return (
    &lt;ul&gt;
      {todoList.map((x, i) =&gt; (
        &lt;li key={i}&gt;
          {x.deadline} {x.todo} by {x.user_id} at
          {x.created_at} {x.updated_at}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<h2 id="動作確認-9"><a class="header" href="#動作確認-9">動作確認</a></h2>
<p>一覧画面にアクセスし，dummy のデータが一覧で表示されれば OK．</p>
<pre><code class="language-txt">2022-02-02 test1 by 1 at &quot;2021-08-10T04:47:27.316Z&quot; &quot;2021-08-10T04:47:27.316Z&quot;
2022-02-22 test2 by 2 at &quot;2021-08-10T04:47:27.316Z&quot; &quot;2021-08-10T04:47:27.316Z&quot;
2022-02-28 test3 by 3 at &quot;2021-08-10T04:47:27.316Z&quot; &quot;2021-08-10T04:47:27.316Z&quot;
</code></pre>
<h2 id="データ取得処理の追加"><a class="header" href="#データ取得処理の追加">データ取得処理の追加</a></h2>
<p>API サーバから todo のデータを取得する処理を追加する．</p>
<p>1 回め講義の Google books API データ取得時と同様に <code>useState</code> と <code>useEffect</code> を用いた実装としている．</p>
<pre><code class="language-js">// src/pages/TodoIndex.jsx

import { useState, useEffect } from &quot;react&quot;;
import axios from &quot;axios&quot;;

export const TodoIndex = () =&gt; {
  // 省略

  // 🔽 編集
  const [todoList, setTodoList] = useState(null);

  // 🔽 追加
  const getAllTodo = async () =&gt; {
    const result = await axios.get(&quot;http://localhost:3001/todo&quot;);
    setTodoList(result.data.result);
    return result;
  };

  // 🔽 追加
  useEffect(() =&gt; {
    getAllTodo();
  }, []);

  return (
    &lt;ul&gt;
      {todoList?.map((x, i) =&gt; (
        &lt;li key={i}&gt;
          {x.deadline} {x.todo} by {x.user_id}
          {x.created_at} {x.updated_at}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<h2 id="動作確認-10"><a class="header" href="#動作確認-10">動作確認</a></h2>
<blockquote>
<p>必ずサーバ側のアプリケーションを動作させてくこと！！</p>
</blockquote>
<p>ブラウザで動作を確認する．</p>
<p>一覧画面に Supabase に保存されているデータが表示されれば OK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コンポーネントの最適化"><a class="header" href="#コンポーネントの最適化">コンポーネントの最適化</a></h1>
<p>各 todo の内容はシンプルなのでこのままでも問題ないが，より複雑な情報を扱う場合には個別のコンポーネントに分けることが望ましい．</p>
<p>また，todo リストのアプリケーションなので，完了未完了が区別できるようチェックボックスを追加する．</p>
<h2 id="必要なファイルの準備-1"><a class="header" href="#必要なファイルの準備-1">必要なファイルの準備</a></h2>
<p><code>src/components</code>フォルダの中に各 todo を表示する<code>Todo.jsx</code>を作成する．</p>
<p>以下の内容を記載する．</p>
<pre><code class="language-js">// src/components/Todo.jsx

export const Todo = () =&gt; {
  return (
    &lt;li&gt;
      &lt;p&gt;deadline todo by user_id at created_at and updated_at&lt;/p&gt;
    &lt;/li&gt;
  );
};
</code></pre>
<h2 id="一覧画面の編集"><a class="header" href="#一覧画面の編集">一覧画面の編集</a></h2>
<p><code>TodoIndex.jsx</code>を以下のように編集する．</p>
<pre><code class="language-js">import { useState, useEffect } from &quot;react&quot;;
import axios from &quot;axios&quot;;
// 🔽 追加
import { Todo } from &quot;../components/Todo&quot;;

export const TodoIndex = () =&gt; {
  // 省略

  // 🔽 編集
  return (
    &lt;ul&gt;
      {todoList?.map((x) =&gt; (
        &lt;Todo
          id={x.id}
          todo={x.todo}
          deadline={x.deadline}
          is_done={x.is_done}
          user_id={x.user_id}
          created_at={x.created_at}
          updated_at={x.updated_at}
        /&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<h2 id="個別ツイートコンポーネントの実装"><a class="header" href="#個別ツイートコンポーネントの実装">個別ツイートコンポーネントの実装</a></h2>
<p><code>Todo.jsx</code>コンポーネントを以下のように編集する．</p>
<p>このコンポーネントは<code>id</code>，<code>todo</code>， <code>deadline</code>, <code>is_done</code>, <code>user_id</code>，<code>created_at</code>，<code>updated_at</code>の 7 つのパラメータを入力することとする．</p>
<pre><code class="language-js">// src/components/Todo.jsx

export const Todo = ({
  id,
  todo,
  deadline,
  is_done,
  user_id,
  created_at,
  updated_at,
}) =&gt; {
  return (
    &lt;li key={id} id={id}&gt;
      &lt;input type=&quot;checkbox&quot; checked={is_done} /&gt;
      &lt;p&gt;
        {deadline} {todo} by {user_id} at {created_at} and {updated_at}
      &lt;/p&gt;
    &lt;/li&gt;
  );
};
</code></pre>
<h2 id="動作確認-11"><a class="header" href="#動作確認-11">動作確認</a></h2>
<p>これまでと同様に todo の一覧が表示されれば OK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="todo-更新処理の作成"><a class="header" href="#todo-更新処理の作成">todo 更新処理の作成</a></h1>
<p>更新の処理を追加する．今回はチェックボックスで完了未完了の変更をできるようにする．</p>
<p>流れは以下のとおり．</p>
<ul>
<li>
<p><code>onChange</code> を用いて，チェックボックスの切り替えを検出する．</p>
</li>
<li>
<p>切り替えのタイミングで更新処理の関数を実行する．<code>is_done</code> の「true」「false」を入れ替えてサーバに送信する．</p>
</li>
<li>
<p>更新処理終了後は，更新後の最新データを反映させるため，<code>TodoIndex.jsx</code> から入力されたデータ取得関数を実行している．</p>
</li>
</ul>
<blockquote>
<p>補足</p>
<p>サーバへ送信するデータについてはサーバ側で定めている．実装の際に確認しておくこと．</p>
</blockquote>
<h2 id="更新処理の追加"><a class="header" href="#更新処理の追加">更新処理の追加</a></h2>
<p><code>Todo.jsx</code> を以下のように編集する．</p>
<pre><code class="language-js">// src/components/Todo.jsx

import axios from &quot;axios&quot;;

export const Todo = ({
  id,
  todo,
  deadline,
  is_done,
  user_id,
  created_at,
  updated_at,
  getData,
}) =&gt; {
  const updateTodoData = async (params) =&gt; {
    const newData = { ...params, ...{ is_done: is_done ? false : true } };
    const requestUrl = &quot;http://localhost:3001/todo&quot;;
    const updatedData = await axios.put(`${requestUrl}/${params.id}`, newData);
    const result = await getData();
    return updatedData;
  };

  return (
    &lt;li key={id} id={id}&gt;
      {/* 🔽 編集 */}
      &lt;input
        type=&quot;checkbox&quot;
        checked={is_done}
        onChange={() =&gt;
          updateTodoData({ id, todo, deadline, is_done, user_id })
        }
      /&gt;
      &lt;p&gt;
        {deadline} {todo} by {user_id} at {created_at} and {updated_at}
      &lt;/p&gt;
    &lt;/li&gt;
  );
};
</code></pre>
<p>更新処理終了後には最新のデータを取得する必要があるので，一覧画面表示から関数を入力する．</p>
<pre><code class="language-js">// src/pages/TodoIndex.jsx

import { useState, useEffect } from &quot;react&quot;;
import axios from &quot;axios&quot;;
import { Todo } from &quot;../components/Todo&quot;;

export const TodoIndex = () =&gt; {
  // 省略

  return (
    &lt;ul&gt;
      {todoList?.map((x, i) =&gt; (
        &lt;Todo
          id={x.id}
          todo={x.todo}
          deadline={x.deadline}
          is_done={x.is_done}
          user_id={x.user_id}
          created_at={x.created_at}
          updated_at={x.updated_at}
          // 🔽 追加
          getData={getAllTodo}
        /&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<h2 id="動作確認-12"><a class="header" href="#動作確認-12">動作確認</a></h2>
<p>チェックボックスをクリックし，切り替われば OK！</p>
<p>Supabase の管理画面でもデータ（is_done）が更新されていることを確認する．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="todo-削除処理の作成"><a class="header" href="#todo-削除処理の作成">todo 削除処理の作成</a></h1>
<p>削除の処理を追加する．手順は以下のとおり．</p>
<ul>
<li>
<p>axios を用いて，Node.js 側で実装した削除の URL にリクエストを送信する．</p>
</li>
<li>
<p>削除には「id」があれば良い．</p>
</li>
<li>
<p>更新と同様，削除処理完了後に最新データ取得の処理を実行する．</p>
</li>
</ul>
<h2 id="削除処理の追加"><a class="header" href="#削除処理の追加">削除処理の追加</a></h2>
<p><code>Todo.jsx</code> を以下のように編集する．</p>
<pre><code class="language-js">// src/components/Todo.jsx

import axios from &quot;axios&quot;;

export const Todo = ({
  id,
  todo,
  deadline,
  is_done,
  user_id,
  created_at,
  updated_at,
  getData,
}) =&gt; {
  const updateTodoData = async (params) =&gt; {
    const newData = { ...params, ...{ is_done: is_done ? false : true } };
    const requestUrl = &quot;http://localhost:3001/todo&quot;;
    const updatedData = await axios.put(`${requestUrl}/${params.id}`, newData);
    const result = await getData();
    return updatedData;
  };

  // 🔽 追加
  const deleteTodoData = async (id) =&gt; {
    const requestUrl = &quot;http://localhost:3001/todo&quot;;
    const removedData = await axios.delete(`${requestUrl}/${id}`);
    const result = await getData();
    return removedData;
  };

  return (
    &lt;li key={id} id={id}&gt;
      &lt;input
        type=&quot;checkbox&quot;
        checked={is_done}
        onChange={() =&gt;
          updateTodoData({ id, todo, deadline, is_done, user_id })
        }
      /&gt;
      {/* 🔽 追加 */}
      &lt;button type=&quot;button&quot; onClick={() =&gt; deleteTodoData(id)}&gt;
        delete
      &lt;/button&gt;
      &lt;p&gt;
        {deadline} {todo} by {user_id} at {created_at} and {updated_at}
      &lt;/p&gt;
    &lt;/li&gt;
  );
};
</code></pre>
<h2 id="動作確認-13"><a class="header" href="#動作確認-13">動作確認</a></h2>
<p>delete ボタンをクリックし，該当するデータが削除されれば OK！</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="todo-一覧画面本日の作成"><a class="header" href="#todo-一覧画面本日の作成">todo 一覧画面（本日）の作成</a></h1>
<p>締切が本日以前の todo のみ表示する画面を作成する．</p>
<p>全件表示とほぼ同様だが，データ取得関数のリクエスト先が異なる．</p>
<p>データ取得後は，個別 Todo コンポーネントを動かすだけなので新たな実装は必要ない．</p>
<pre><code class="language-js">// src/pages/TodoToday.jsx

import { useState, useEffect } from &quot;react&quot;;
import axios from &quot;axios&quot;;
import { Todo } from &quot;../components/Todo&quot;;

export const TodoToday = () =&gt; {
  const [todoList, setTodoList] = useState(null);

  const getTodayTodo = async () =&gt; {
    const result = await axios.get(&quot;http://localhost:3001/todo/today&quot;);
    setTodoList(result.data.result);
    return result;
  };

  useEffect(() =&gt; {
    getTodayTodo();
  }, []);

  return (
    &lt;ul&gt;
      {todoList?.map((x, i) =&gt; (
        &lt;Todo
          hoge={i}
          id={x.id}
          todo={x.todo}
          deadline={x.deadline}
          is_done={x.is_done}
          user_id={x.user_id}
          created_at={x.created_at}
          updated_at={x.updated_at}
          getData={getTodayTodo}
        /&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<h2 id="動作確認-14"><a class="header" href="#動作確認-14">動作確認</a></h2>
<p>一覧画面（本日）にアクセスし，実行日以前のデータのみ表示されれば OK！</p>
<p>合わせて，更新と削除の処理が動作することも確認しておく．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="データ取得タイミングの最適化"><a class="header" href="#データ取得タイミングの最適化">データ取得タイミングの最適化</a></h1>
<p>ここまで，講義 1 回めで使用した <code>useEffect</code> を用いてデータを取得していたが，最新の情報を取得するには再度読み込みを行う必要があった．</p>
<p>しかし，頻繁に情報が更新されるアプリケーションの場合，ユーザの再読込をトリガにしたデータ取得は現実的ではない．</p>
<p>本項では，様々なデータ取得タイミングを解説し，本アプリケーションに適した処理を実装する．</p>
<h2 id="データ取得と反映方法の紹介"><a class="header" href="#データ取得と反映方法の紹介">データ取得と反映方法の紹介</a></h2>
<p>雑な紹介は以下のとおり．</p>
<table><thead><tr><th>名称</th><th>概要</th></tr></thead><tbody>
<tr><td>SSR</td><td>サーバ側で HTML を生成する方式．クライアント側で JS が実行されなくてもコンテンツが存在する状況となる．</td></tr>
<tr><td>SSG</td><td>サーバ上で，MD ファイルなどから HTML ファイルを生成し，クライアント側からは HTML ファイルを読むだけにする方式．サーバ上には静的な（static） HTML が置かれている状況となる．ソースデータが更新された場合は開発者側が再度ビルドを行う必要がある．</td></tr>
<tr><td>ISR</td><td>SSG を効率よく実現するための方法．指定時間毎に SSG のビルドを行うことができる．開発者が都度ビルドを行うことなく，アプリケーションの状態を最新に保つことができる．</td></tr>
<tr><td>CSR</td><td>クライアント側で動作する JS が HTML 要素を生成する方式．主にサーバから JSON 形式のデータを受け取り， JS が HTML 要素を構築して画面に表示される流れとなる．React では useEffect や axios を使用した一般的な実装．</td></tr>
<tr><td>SWR</td><td>CSR を効率よく実現するための方法．クライアント側で再読込を行わなくても，指定時間毎やユーザ操作のタイミングでデータ取得処理を動作させることができる．useSWR を使用して実装が可能．</td></tr>
</tbody></table>
<h2 id="使い分け-1"><a class="header" href="#使い分け-1">使い分け</a></h2>
<p>データを取得するタイミングによる．</p>
<p>クライアント側の状態をどの程度の頻度で最新に保つ必要があるのかにより，最適な実装は異なる．</p>
<p>いくつかの例を以下に示す．</p>
<table><thead><tr><th>状況</th><th>実装</th></tr></thead><tbody>
<tr><td>開発者の個人ブログ，ドキュメントなど．</td><td>SSG</td></tr>
<tr><td>ユーザ投稿型のブログなど．</td><td>SSG（ISR 使用）</td></tr>
<tr><td>ユーザ短文投稿型の SNS など．</td><td>CSR（SWR 使用）</td></tr>
</tbody></table>
<p>より厳密なリアルタイム性が求められる場合（ユーザ同士のチャットアプリケーションなど）にはサーバ側で web socket の実装などを行う必要がある．</p>
<h2 id="実装-1"><a class="header" href="#実装-1">実装</a></h2>
<p>今回のアプリケーションでは，すでに CSR にて実装を行っている．</p>
<p>todo 一覧表示において，より柔軟なタイミングで最新のデータが取得できるよう SWR を用いた実装を追加で行う．</p>
<h2 id="swr-処理の実装"><a class="header" href="#swr-処理の実装">SWR 処理の実装</a></h2>
<p>SWR の機能はライブラリとして提供されている．</p>
<p>下記コマンドでインストールする．</p>
<pre><code class="language-bash">$ npm i swr
</code></pre>
<p><code>TodoIndex.jsx</code> を以下のように編集する．</p>
<p>データを取得するための <code>fetcher</code> 関数を定義し，<code>useSWR</code> で「リクエスト先」と「データ取得関数」を指定する．</p>
<blockquote>
<p>解説</p>
<ul>
<li>
<p>取得したデータと失敗した場合のエラーはそれぞれ <code>data</code> と <code>error</code> に格納される．</p>
</li>
<li>
<p>データが取得できなかった場合やエラーが発生しない場合はそれぞれ <code>undefined</code> となるため，容易に条件分岐することができる．</p>
</li>
</ul>
</blockquote>
<pre><code class="language-js">// src/pages/TodoIndex.jsx

// 省略

// 🔽 追加
import useSWR from &quot;swr&quot;;

export const TodoIndex = () =&gt; {
  // 省略

  // 🔽 追加
  const fetcher = async (url) =&gt; (await axios.get(url)).data.result;

  // 🔽 追加
  const { data, error } = useSWR(&quot;http://localhost:3001/todo&quot;, fetcher);

  // 🔽 追加
  return (
    &lt;ul&gt;
      {data?.map((x, i) =&gt; (
        &lt;Todo
          key={x.id}
          id={x.id}
          todo={x.todo}
          deadline={x.deadline}
          is_done={x.is_done}
          user_id={x.user_id}
          created_at={x.created_at}
          updated_at={x.updated_at}
          getData={getAllTodo}
        /&gt;
      ))}
    &lt;/ul&gt;
  );
};
</code></pre>
<h2 id="動作確認-15"><a class="header" href="#動作確認-15">動作確認</a></h2>
<p>これまでと同様の動作になっていれば OK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="データ取得タイミングの調整"><a class="header" href="#データ取得タイミングの調整">データ取得タイミングの調整</a></h1>
<p>SWR を使用すると，様々なタイミングでデータ取得の処理を実行することができる．</p>
<h2 id="swr-のオプション設定"><a class="header" href="#swr-のオプション設定">SWR のオプション設定</a></h2>
<p>今回は以下の 2 パターンでデータを取得する処理を実装してみる．</p>
<ul>
<li>
<p>ユーザの操作によらず 3 秒毎にデータ取得．</p>
</li>
<li>
<p>ユーザがウインドウをアクティブにしたタイミングでデータ取得．</p>
</li>
</ul>
<p>その他のオプションはドキュメント参照．</p>
<p><a href="https://swr.vercel.app/docs/options">https://swr.vercel.app/docs/options</a></p>
<p><code>TodoIndex.jsx</code>を以下のように編集する．</p>
<pre><code class="language-js">// src/pages/TodoIndex.jsx

// 省略

const fetcher = async (url) =&gt; (await axios.get(url)).data.result;

const options = {
  // 初期データ
  initialData: null,
  // pollingの期間（ミリ秒）
  refreshInterval: 3000,
  // windowのフォーカス時にRevalidateする
  revalidateOnFocus: true,
};

const { data, error } = useSWR(&quot;http://localhost:3001/todo&quot;, fetcher, options);

// 省略
</code></pre>
<h2 id="動作確認-16"><a class="header" href="#動作確認-16">動作確認</a></h2>
<p>タブを 2 つ用意し，両方とも実装中のアプリケーションを開く．片方は「 todo 送信画面」もう片方は「一覧画面」を表示しておく．</p>
<p>送信画面側で todo を送信し，一覧画面を操作しなくても自動的に表示されれば OK．</p>
<p>なにもしなくてもデータ取って表示できる．すごい．</p>
<blockquote>
<p>補足</p>
<ul>
<li>
<p><code>TodoToday.jsx</code> でも同様の処理でデータを取得してみよう．</p>
</li>
<li>
<p>更新及び削除処理と組み合わせる場合など，任意のタイミングでデータを反映できる useEffect のほうが適している場合もある．</p>
</li>
<li>
<p>useSWR には「mutate」という機能があり，データを post しながら先取りして更新できる仕組みもあるので，興味がある人はチャレンジしてみよう！</p>
</li>
</ul>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="slack-連携機能のテスト画面実装"><a class="header" href="#slack-連携機能のテスト画面実装">Slack 連携機能のテスト画面実装</a></h1>
<p>サーバサイドで実装した Slack 投稿の処理を動かすためのテスト画面を作成する．</p>
<p><code>src/components</code> 内に <code>TestSlack.jsx</code> を作成する．</p>
<p>ファイルを作成したらルーティングを追加する．<code>App.jsx</code> を以下のように編集する．</p>
<pre><code class="language-js">// src/App.jsx

// 省略

// 🔽 追加
import { TestSlack } from &quot;./pages/TestSlack&quot;;

// 省略

&lt;BrowserRouter&gt;
  &lt;h1&gt;Todoリストアプリケーション&lt;/h1&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;Link to=&quot;/todo/index&quot;&gt;todo 一覧（全件）&lt;/Link&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;Link to=&quot;/todo/today&quot;&gt;todo 一覧（本日）&lt;/Link&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;Link to=&quot;/todo/post&quot;&gt;todo 入力&lt;/Link&gt;
    &lt;/li&gt;
    {/* 🔽 追加 */}
    &lt;li&gt;
      &lt;Link to=&quot;/test-slack&quot;&gt;test slack&lt;/Link&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;hr /&gt;
  &lt;Routes&gt;
    &lt;Route path=&quot;/todo/index&quot; element={&lt;TodoIndex /&gt;} /&gt;
    &lt;Route path=&quot;/todo/today&quot; element={&lt;TodoToday /&gt;} /&gt;
    &lt;Route path=&quot;/todo/post&quot; element={&lt;TodoPost /&gt;} /&gt;
    {/* 🔽 追加 */}
    &lt;Route path=&quot;/test-slack&quot; element={&lt;TestSlack /&gt;} /&gt;
    &lt;Route path=&quot;/*&quot; element={&lt;NotFound /&gt;} /&gt;
  &lt;/Routes&gt;
&lt;/BrowserRouter&gt;;
</code></pre>
<p>続いて，<code>TestSlack.jsx</code> を以下のように編集する．内容は以下のとおり．</p>
<ul>
<li>
<p><code>postAllTodo</code> 関数はデータ全件を Slack に投稿する URL にリクエストを送信する．</p>
</li>
<li>
<p><code>postTodayTodo</code> 関数は実行日以前のデータを Slack に投稿する URL にリクエストを送信する．</p>
</li>
<li>
<p><code>onClick</code> でクリック時に上記関数を実行するように設定する．</p>
</li>
</ul>
<pre><code class="language-js">// src/pages/TestSlack.jsx

import axios from &quot;axios&quot;;

export const TestSlack = () =&gt; {
  const postAllTodo = async () =&gt; {
    const result = await axios.get(&quot;http://localhost:3001/slack&quot;);
    console.log(result);
    return result;
  };

  const postTodayTodo = async () =&gt; {
    const result = await axios.get(&quot;http://localhost:3001/slack/today&quot;);
    console.log(result);
    return result;
  };

  return (
    &lt;&gt;
      &lt;button type=&quot;button&quot; onClick={postAllTodo}&gt;
        All
      &lt;/button&gt;
      &lt;button type=&quot;button&quot; onClick={postTodayTodo}&gt;
        Today
      &lt;/button&gt;
    &lt;/&gt;
  );
};
</code></pre>
<h2 id="動作確認-17"><a class="header" href="#動作確認-17">動作確認</a></h2>
<p>各ボタンをクリックし，Slack に該当するデータが投稿されれば OK！！</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ-3"><a class="header" href="#まとめ-3">まとめ</a></h1>
<p>今回は todo アプリケーションのクライアント側を実装し，サーバ側と連携を行った．</p>
<p>クライアント側では，ユーザがどのようにアプリケーションを使用するかによって最適な実装が異なる．</p>
<p>フロントエンドの技術は画面の見え方だけではない．ユーザがストレスなくデータにアクセスできる環境を整備したり，必要なタイミングでデータの送受信ができるようにしたりなどの視点も大切である．</p>
<p>また，今回はフロント-サーバ間を完全に分離し，やり取りするデータの形式を明確にした．</p>
<p>このような開発方式をスキーマ駆動開発と呼ぶ．実装順はサーバ・フロントどちらでもよく，チーム開発ならば同時進行できる．</p>
<p>今回は以上である( `･ω･´)b</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
