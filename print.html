<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>todo-with-slack</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> はじめに</a></li><li class="chapter-item expanded "><a href="api-00/index.html"><strong aria-hidden="true">2.</strong> サーバ編 ①（Node.js）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api-00/get-started.html"><strong aria-hidden="true">2.1.</strong> Cloud Functions と Express</a></li><li class="chapter-item expanded "><a href="api-00/setup.html"><strong aria-hidden="true">2.2.</strong> 環境構築</a></li><li class="chapter-item expanded "><a href="api-00/serve-deploy.html"><strong aria-hidden="true">2.3.</strong> 動作確認とデプロイ</a></li><li class="chapter-item expanded "><a href="api-00/install-express.html"><strong aria-hidden="true">2.4.</strong> Express の導入</a></li><li class="chapter-item expanded "><a href="api-00/get-params.html"><strong aria-hidden="true">2.5.</strong> Express での値の受け取り</a></li><li class="chapter-item expanded "><a href="api-00/request.html"><strong aria-hidden="true">2.6.</strong> http リクエストの実装</a></li><li class="chapter-item expanded "><a href="api-00/cors.html"><strong aria-hidden="true">2.7.</strong> CORS 対策</a></li><li class="chapter-item expanded "><a href="api-00/work.html"><strong aria-hidden="true">2.8.</strong> 課題</a></li></ol></li><li class="chapter-item expanded "><a href="api-01/index.html"><strong aria-hidden="true">3.</strong> サーバ編補足（Node.js）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api-01/about-nodejs.html"><strong aria-hidden="true">3.1.</strong> Node.js とは</a></li><li class="chapter-item expanded "><a href="api-01/prepare-api.html"><strong aria-hidden="true">3.2.</strong> API 実装の準備</a></li><li class="chapter-item expanded "><a href="api-01/install-express.html"><strong aria-hidden="true">3.3.</strong> Express のインストール</a></li><li class="chapter-item expanded "><a href="api-01/omikuji-api01.html"><strong aria-hidden="true">3.4.</strong> API 実装 1（おみくじ初級編）</a></li><li class="chapter-item expanded "><a href="api-01/add-command.html"><strong aria-hidden="true">3.5.</strong> コマンドの追加</a></li><li class="chapter-item expanded "><a href="api-01/omikuji-api02.html"><strong aria-hidden="true">3.6.</strong> API 実装 2（おみくじ中級編）</a></li><li class="chapter-item expanded "><a href="api-01/janken-api.html"><strong aria-hidden="true">3.7.</strong> API 実装 3（じゃんけん）</a></li><li class="chapter-item expanded "><a href="api-01/summary.html"><strong aria-hidden="true">3.8.</strong> まとめ</a></li></ol></li><li class="chapter-item expanded "><a href="api-02/index.html"><strong aria-hidden="true">4.</strong> サーバ編 ②（Node.js）</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="api-02/about-perpetuation.html"><strong aria-hidden="true">4.1.</strong> データの永続化について</a></li><li class="chapter-item expanded "><a href="api-02/setup-supabase.html"><strong aria-hidden="true">4.2.</strong> Supabase の準備</a></li><li class="chapter-item expanded "><a href="api-02/setup-files.html"><strong aria-hidden="true">4.3.</strong> ファイル作成と動作確認</a></li><li class="chapter-item expanded "><a href="api-02/crud-create.html"><strong aria-hidden="true">4.4.</strong> Create の処理</a></li><li class="chapter-item expanded "><a href="api-02/crud-read-all.html"><strong aria-hidden="true">4.5.</strong> Read の処理（全件）</a></li><li class="chapter-item expanded "><a href="api-02/crud-read-today.html"><strong aria-hidden="true">4.6.</strong> Read の処理（本日以前）</a></li><li class="chapter-item expanded "><a href="api-02/crud-update.html"><strong aria-hidden="true">4.7.</strong> Update の処理</a></li><li class="chapter-item expanded "><a href="api-02/crud-delete.html"><strong aria-hidden="true">4.8.</strong> Delete の処理</a></li><li class="chapter-item expanded "><a href="api-02/connect-to-slack.html"><strong aria-hidden="true">4.9.</strong> Slack 連携設定</a></li><li class="chapter-item expanded "><a href="api-02/post-to-slack.html"><strong aria-hidden="true">4.10.</strong> Slack 連携実装</a></li><li class="chapter-item expanded "><a href="api-02/summary.html"><strong aria-hidden="true">4.11.</strong> まとめ</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">todo-with-slack</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="はじめに"><a class="header" href="#はじめに">はじめに</a></h1>
<p>本講座では，Node.js と React を用いた todo アプリケーション開発に挑戦します．</p>
<p>どちらも JavaScript で記述を行うため，言語を少し触った人であれば問題なくコードを書くことができます．</p>
<p>全 4 回を通して todo アプリケーションを実装しながら，基本的な実装方法やポイントとなる考え方を押さえます．</p>
<h2 id="実装するアプリケーション"><a class="header" href="#実装するアプリケーション">実装するアプリケーション</a></h2>
<p>アプリケーションの全体像はサーバサイドとフロントエンドが API を通じて連携する構成となっています．サーバ側の API は Node.js，フロント側は React で実装します．</p>
<p>開発時にはサーバ - フロント間で通信に用いるデータの形式を定めておき，サーバとフロントはそれぞれ独立させて実装を進めます．このような開発を「スキーマ駆動開発」と呼びます．</p>
<h3 id="サーバサイドの実装"><a class="header" href="#サーバサイドの実装">サーバサイドの実装</a></h3>
<p>まず始めに Node.js 側でアプリケーションの機能を一通り実装します．ここでは基本の CRUD 処理を中心とし，BaaS を用いたデータの永続化，Slack との連携機能を取り入れます．</p>
<p>この時点ではターミナルからのコマンド操作で各機能が動作する状態になります．</p>
<ul>
<li>
<p>アプリケーションの機能一覧（サーバ側）</p>
<ul>
<li>
<p>新規 todo の作成．</p>
</li>
<li>
<p>todo 全件の一覧表示．</p>
</li>
<li>
<p>締切が実行日以前の todo 一覧表示．</p>
</li>
<li>
<p>既存 todo の更新．</p>
</li>
<li>
<p>既存 todo の削除．</p>
</li>
<li>
<p>todo 全件を指定時間に Slack の指定チャンネルに投稿．</p>
</li>
<li>
<p>締切が実行日以前の todo を指定時間に Slack の指定チャンネルに投稿．</p>
</li>
</ul>
</li>
</ul>
<h3 id="フロントエンドの実装"><a class="header" href="#フロントエンドの実装">フロントエンドの実装</a></h3>
<p>続いて，React を用いてフロントエンドの実装を行います．先に実装したサーバ側アプリケーションと連携することで，全ての機能をブラウザからの操作で実行することが可能になります．</p>
<ul>
<li>
<p>アプリケーションの画面構成（フロント側）</p>
<ul>
<li>
<p>todo 入力画面（新規 todo 作成を実行）．</p>
</li>
<li>
<p>todo 全件一覧画面（データ全件取得，更新，削除を実行）．</p>
</li>
<li>
<p>締切が実行日以前の todo 一覧画面（データ一部取得，更新，削除を実行）．</p>
</li>
</ul>
</li>
</ul>
<h2 id="講座の流れ"><a class="header" href="#講座の流れ">講座の流れ</a></h2>
<p>講座の流れは以下のとおりです．</p>
<ul>
<li>
<p>第 1 回目</p>
<ul>
<li>Node.js の基本的な動かし方，実装方法を学ぶ．サーバレスでの実装に挑戦．</li>
</ul>
</li>
<li>
<p>第 2 回目</p>
<ul>
<li>Node.js を用いて，アプリケーション（サーバ側）の実装を行う．</li>
</ul>
</li>
<li>
<p>第 3 回目</p>
<ul>
<li>React の基本的な動かし方，実装方法を学ぶ．</li>
</ul>
</li>
<li>
<p>第 4 回目</p>
<ul>
<li>React を用いて，アプリケーション（フロント側）の実装を行う．</li>
</ul>
</li>
</ul>
<h2 id="事前準備"><a class="header" href="#事前準備">事前準備</a></h2>
<p>Node.js の動作する環境が必要となる．ターミナルで以下のコマンドを実行し，バージョンが表示されれば OK．</p>
<p>Node.js をインストールする方法は複数あるが，どの方法でも良い．</p>
<pre><code class="language-bash">$ node -v
v16.13.0

# v16.*.* であればOK．

</code></pre>
<pre><code class="language-bash">$ npm -v
8.1.0

# 8.*.* であればOK．

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="サーバ編-①nodejs"><a class="header" href="#サーバ編-①nodejs">サーバ編 ①（Node.js）</a></h1>
<h2 id="今日のゴール"><a class="header" href="#今日のゴール">今日のゴール</a></h2>
<ul>
<li>
<p>Cloud Functions で Express を用いた Node.js を実装し，動作を確認する．</p>
</li>
<li>
<p>Cloud Functions を使った開発の手順を把握する．</p>
</li>
<li>
<p>Node.js の開発手順の感覚を掴む．</p>
</li>
</ul>
<h2 id="今回実装するアプリケーション"><a class="header" href="#今回実装するアプリケーション">今回実装するアプリケーション</a></h2>
<ul>
<li>
<p>Cloud Functions 上で Google books API から情報を取得する．</p>
</li>
<li>
<p>クライアントから送信されてきたキーワードを受け取り，API に投げる．</p>
</li>
<li>
<p>API から返ってきたデータをクライアントに送信する．</p>
</li>
<li>
<p>Cloud Functions を利用することでサーバを用意することなく API を実装！</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cloud-functions-と-express"><a class="header" href="#cloud-functions-と-express">Cloud Functions と Express</a></h1>
<h2 id="cloud-functions-の特徴と利点"><a class="header" href="#cloud-functions-の特徴と利点">Cloud Functions の特徴と利点</a></h2>
<h3 id="概要--特徴"><a class="header" href="#概要--特徴">概要 / 特徴</a></h3>
<ul>
<li>
<p>イベントドリブンのサーバーレスコンピューティングプラットフォーム．</p>
</li>
<li>
<p>Firebase 上で Node.js で記述した関数を実行することができる．</p>
</li>
</ul>
<h3 id="利点"><a class="header" href="#利点">利点</a></h3>
<ul>
<li>
<p>サーバーのプロビジョニング，管理，アップグレードが不要．</p>
</li>
<li>
<p>負荷に応じた自動スケーリング．</p>
</li>
<li>
<p>異なる言語にまたがる，複雑なアプリケーション開発を簡素化．</p>
</li>
</ul>
<p><a href="https://firebase.google.com/docs/functions?hl=ja">参考（ドキュメント）</a></p>
<h2 id="express-の特徴と利点"><a class="header" href="#express-の特徴と利点">Express の特徴と利点</a></h2>
<h3 id="概要--特徴-1"><a class="header" href="#概要--特徴-1">概要 / 特徴</a></h3>
<ul>
<li>
<p>最小限で柔軟な Node.js Web アプリケーション・フレームワーク．</p>
</li>
<li>
<p>無数の HTTP ユーティリティー・メソッドとミドルウェアを自由に使用できるため，堅固な API を迅速かつ容易に作成できる．</p>
</li>
<li>
<p>ほぼデファクトスタンダード．</p>
</li>
</ul>
<h3 id="利点-1"><a class="header" href="#利点-1">利点</a></h3>
<ul>
<li>
<p>Routing の設定が非常にわかりやすい．</p>
</li>
<li>
<p>環境構築が楽．</p>
</li>
<li>
<p>情報がとにかく多い．</p>
</li>
</ul>
<p><a href="https://expressjs.com/ja/">参考（ドキュメント）</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="環境構築"><a class="header" href="#環境構築">環境構築</a></h1>
<h2 id="必要なツールのバージョン確認"><a class="header" href="#必要なツールのバージョン確認">必要なツールのバージョン確認</a></h2>
<ul>
<li>
<p>Node.js と npm が必要なので，以下のコマンドで状況を確認する．</p>
</li>
<li>
<p>バージョンが表示されれば OK．</p>
</li>
</ul>
<pre><code class="language-bash">$ node -v
v16.13.0
$ npm -v
8.1.0
</code></pre>
<h2 id="firebase-のプロジェクト作成"><a class="header" href="#firebase-のプロジェクト作成">Firebase のプロジェクト作成</a></h2>
<ul>
<li>
<p>Firebase のコンソールにログインし，新規プロジェクトを作成する．</p>
</li>
<li>
<p>プロジェクト名は任意（今回は<code>20200601-functions</code>）．</p>
</li>
<li>
<p>DB などは特に設定しなくて OK（下記画面が表示された段階で OK）．</p>
</li>
</ul>
<p><img src="api-00/./images/project_view01.png" alt="firebaseプロジェクト画面" /></p>
<h2 id="fiirebase-を扱うツールのインストール"><a class="header" href="#fiirebase-を扱うツールのインストール">Fiirebase を扱うツールのインストール</a></h2>
<ul>
<li>
<p>firebase 関連のコマンドを実行するため，下記のコマンドでインストールする．</p>
</li>
<li>
<p><code>-g</code>をつけてグローバルにインストールする．</p>
</li>
<li>
<p>すでにインストールしている場合も，下記コマンドで最新版にアップデートできるため必ず行う．</p>
</li>
</ul>
<pre><code class="language-bash">$ npm install -g firebase-tools
</code></pre>
<p>実行結果</p>
<pre><code class="language-bash">+ firebase-tools@8.9.0
added 592 packages from 360 contributors in 17.497s
</code></pre>
<p>【注意】バージョンが<code>8.4.0</code>の場合は後々エラーが発生して先へ進めなくなるので必ず<code>8.4.1</code>以上にしておくこと．</p>
<h2 id="雛形の作成"><a class="header" href="#雛形の作成">雛形の作成</a></h2>
<ul>
<li>
<p>適当な場所にディレクトリを作成し，ターミナルで移動して必要なファイルを準備する．</p>
</li>
<li>
<p>今回は例としてデスクトップに<code>20200601cloudfunctions</code>ディレクトリを作成する．</p>
</li>
<li>
<p>下記コマンドを順番に実行．</p>
</li>
</ul>
<pre><code class="language-bash">$ cd ~/Desktop
$ mkdir 20200601cloudfunctions
$ cd 20200601cloudfunctions
$ firebase init
</code></pre>
<ul>
<li>下記エラーが表示された場合はログインする．</li>
</ul>
<pre><code class="language-bash">Error: Failed to authenticate, have you run firebase login?
</code></pre>
<ul>
<li>下記コマンドでログイン．</li>
</ul>
<pre><code class="language-bash">$ firebase login
</code></pre>
<ul>
<li>
<p><code>firebase init</code>がうまくいくと選択肢が出るので，十字キーで<code>Functions</code>を選択してスペースキーでチェックを入れる（下図参照）．</p>
</li>
<li>
<p>チェックを入れたら Enter．</p>
</li>
</ul>
<pre><code class="language-bash">? Which Firebase CLI features do you want to set up for this folder? Press Space
 to select features, then Enter to confirm your choices.
 ◯ Database: Deploy Firebase Realtime Database Rules
 ◯ Firestore: Deploy rules and create indexes for Firestore
❯◉ Functions: Configure and deploy Cloud Functions
 ◯ Hosting: Configure and deploy Firebase Hosting sites
 ◯ Storage: Deploy Cloud Storage security rules
 ◯ Emulators: Set up local emulators for Firebase features
</code></pre>
<ul>
<li>
<p>続いて，以下の選択肢が表示される．</p>
</li>
<li>
<p><code>Use an existing project</code>を選択して Enter．</p>
</li>
</ul>
<pre><code class="language-bash">? Please select an option: (Use arrow keys)
❯ Use an existing project
  Create a new project
  Add Firebase to an existing Google Cloud Platform project
  Don't set up a default project
</code></pre>
<ul>
<li>プロジェクトの選択肢が出るので，上で作成したプロジェクトを選択して Enter．</li>
</ul>
<pre><code class="language-bash">? Select a default Firebase project for this directory:
  hoge-c83e4 (hoge)
  hoge-791f2 (hogehoge)
  fuga-813c6 (fuga)
❯ functions-69daf (20200601-functions)
  hoge-216007 (hogefuga)
  piyo (piyo)
  hogefuga (hoge-fuga)
</code></pre>
<ul>
<li>選択肢が出るので，<code>JavaScript</code>を選択して Enter．</li>
</ul>
<pre><code class="language-bash">? What language would you like to use to write Cloud Functions? (Use arrow keys)

❯ JavaScript
  TypeScript
</code></pre>
<ul>
<li>以降は下のような感じ．</li>
</ul>
<pre><code class="language-bash">? Do you want to use ESLint to catch probable bugs and enforce style? No
✔  Wrote functions/package.json
✔  Wrote functions/index.js
✔  Wrote functions/.gitignore
? Do you want to install dependencies with npm now? Yes
...
i  Writing configuration info to firebase.json...
i  Writing project information to .firebaserc...
i  Writing gitignore file to .gitignore...

✔  Firebase initialization complete!
</code></pre>
<p>これで準備完了！</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="動作確認とデプロイ"><a class="header" href="#動作確認とデプロイ">動作確認とデプロイ</a></h1>
<h2 id="ファイルの内容確認解説"><a class="header" href="#ファイルの内容確認解説">ファイルの内容確認&amp;解説</a></h2>
<ul>
<li>
<p>必要なファイルが準備されているので，エディタでプロジェクトのフォルダを開く．</p>
</li>
<li>
<p><code>functions/index.js</code>を開くと下記のような内容が記述されている．</p>
</li>
<li>
<p>1 行目はモジュールの読み込み．</p>
</li>
<li>
<p><code>helloWorld</code>は関数名．この関数にリクエストが来ると，<code>Hello from Firebase!</code>という文字列を返すよう記述されている．</p>
</li>
</ul>
<pre><code class="language-js">// functions/index.js
const functions = require(&quot;firebase-functions&quot;);

// // Create and Deploy Your First Cloud Functions
// // https://firebase.google.com/docs/functions/write-firebase-functions
//
// exports.helloWorld = functions.https.onRequest((request, response) =&gt; {
//  response.send(&quot;Hello from Firebase!&quot;);
// });
</code></pre>
<h2 id="編集ローカルサーバーでの動作確認"><a class="header" href="#編集ローカルサーバーでの動作確認">編集&amp;ローカルサーバーでの動作確認</a></h2>
<ul>
<li>下記のように編集する（コメントアウト外すだけ）．</li>
</ul>
<pre><code class="language-js">// functions/index.js
const functions = require(&quot;firebase-functions&quot;);

// // Create and Deploy Your First Cloud Functions
// // https://firebase.google.com/docs/functions/write-firebase-functions
//
exports.helloWorld = functions.https.onRequest((request, response) =&gt; {
  response.send(&quot;Hello from Firebase!&quot;);
});
</code></pre>
<ul>
<li>専用コマンドが用意されているのでローカルサーバーを立ち上げる．</li>
</ul>
<pre><code class="language-bash">$ firebase serve
</code></pre>
<ul>
<li>実行結果</li>
</ul>
<pre><code class="language-bash">=== Serving from '/Users/taroosg/Desktop/20200601cloudfunctions'...

⚠  Your requested &quot;node&quot; version &quot;8&quot; doesn't match your global version &quot;12&quot;
i  functions: Watching &quot;/Users/taroosg/Desktop/20200601cloudfunctions/functions&quot; for Cloud Functions...
✔  functions[helloWorld]: http function initialized (http://localhost:5000/cloudfunctions-3517c/us-central1/helloWorld).

</code></pre>
<ul>
<li>
<p>このとき，ローカルサーバの URL が発行されるためメモしておくことをオススメする（あとから確認もできるが煩雑なため）．</p>
</li>
<li>
<p>ローカルサーバーが立ち上がったらターミナルからリクエストを送る．</p>
</li>
<li>
<p>メッセージ（<code>Hello from Firebase!</code>）が返ってくれば OK！</p>
</li>
</ul>
<pre><code class="language-bash">$ curl http://localhost:5000/cloudfunctions-3517c/us-central1/helloWorld
Hello from Firebase!
</code></pre>
<ul>
<li>確認したら<code>ctrl + c</code>でローカルサーバを停止する．</li>
</ul>
<h2 id="デプロイ--動作確認"><a class="header" href="#デプロイ--動作確認">デプロイ &amp; 動作確認</a></h2>
<blockquote>
<p><strong>【注意】</strong></p>
<ul>
<li>
<p>現在（2022/03/01 時点）で，CloudFunctions のデプロイは支払い登録が必須となっています．</p>
</li>
<li>
<p>Firebase のプロジェクトが無料プラン（Spark プラン）の場合はデプロイがエラーとなるため，前項のローカルサーバでの動作が確認できたら次の項目に進んでください．</p>
</li>
<li>
<p>有料プラン（Blaze プラン）にアップグレードすることでデプロイできるようになるため，デプロイしたい方はプランを変更してください．</p>
</li>
</ul>
</blockquote>
<ul>
<li>
<p>動作確認したらデプロイする．</p>
</li>
<li>
<p>ターミナルで下記を実行．</p>
</li>
</ul>
<pre><code class="language-bash">$ firebase deploy
</code></pre>
<ul>
<li>実行結果</li>
</ul>
<pre><code class="language-bash">=== Deploying to 'fir-todo-8868b'...

i  deploying functions
i  functions: ensuring necessary APIs are enabled...
✔  functions: all necessary APIs are enabled
i  functions: preparing functions directory for uploading...
i  functions: packaged functions (26.53 KB) for uploading
✔  functions: functions folder uploaded successfully
i  functions: creating Node.js 8 function helloWorld(us-central1)...
✔  functions[helloWorld(us-central1)]: Successful create operation.
Function URL (helloWorld): https://hogehoge.cloudfunctions.net/helloWorld

✔  Deploy complete!

Project Console: https://console.firebase.google.com/project/fir-todo-8868b/overview
</code></pre>
<ul>
<li>
<p>このとき，デプロイ先の URL（<code>Function URL (helloWorld):...</code>）が発行されるためメモしておくことをオススメする（あとから確認もできるが煩雑なため）．</p>
</li>
<li>
<p>デプロイが完了したらターミナルからリクエストを送る．</p>
</li>
<li>
<p>メッセージが返ってくれば OK！</p>
</li>
</ul>
<pre><code class="language-bash">$ curl https://hogehoge.cloudfunctions.net/helloWorld
Hello from Firebase!
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="express-の導入"><a class="header" href="#express-の導入">Express の導入</a></h1>
<ul>
<li>
<p>Express は Node.js のフレームワーク．</p>
</li>
<li>
<p>API のエンドポイントを手軽に実装できるので便利．</p>
</li>
<li>
<p>下記コマンドを実行してインストールする．</p>
</li>
<li>
<p>【重要】<code>functions</code>フォルダに移動しておく．</p>
</li>
</ul>
<pre><code class="language-bash">$ cd functions
$ npm install express
</code></pre>
<ul>
<li>
<p>インストールが終わったら index.js を編集する．</p>
</li>
<li>
<p><code>app.get()</code>で API エンドポイントを定義．</p>
</li>
<li>
<p><code>/hello</code>がエンドポイントの URL．リクエスト時に動作させたい関数のエンドポイントを指定する．</p>
</li>
</ul>
<pre><code class="language-js">// index.js

const functions = require(&quot;firebase-functions&quot;);
// Expressの読み込み
const express = require(&quot;express&quot;);

const app = express();

app.get(&quot;/hello&quot;, (req, res) =&gt; {
  // レスポンスの設定
  res.send(&quot;Hello Express!&quot;);
});

// 出力
const api = functions.https.onRequest(app);
module.exports = { api };
</code></pre>
<h2 id="動作確認"><a class="header" href="#動作確認">動作確認</a></h2>
<ul>
<li>保存したら動作確認．</li>
</ul>
<pre><code class="language-bash">$ firebase serve
=== Serving from '/Users/taroosg/Desktop/20200601cloudfunctions'...

⚠  Your requested &quot;node&quot; version &quot;8&quot; doesn't match your global version &quot;12&quot;
i  functions: Watching &quot;/Users/taroosg/Desktop/20200601cloudfunctions/functions&quot; for Cloud Functions...
✔  functions[api]: http function initialized (http://localhost:5000/cloudfunctions-3517c/us-central1/api).

</code></pre>
<ul>
<li>ターミナルからリクエストを送る．</li>
</ul>
<pre><code class="language-bash">$ curl http://localhost:5000/cloudfunctions-3517c/us-central1/api/hello
Hello Express!
</code></pre>
<blockquote>
<p>無料プランの場合はデプロイは飛ばしてください．</p>
</blockquote>
<ul>
<li>
<p>確認したらデプロイ．</p>
</li>
<li>
<p><code>helloworld</code>関数を削除していいかどうか訊かれたら yes で OK．</p>
</li>
</ul>
<pre><code class="language-bash">$ firebase deploy
? Would you like to proceed with deletion? Selecting no will continue the rest o
f the deployments. Yes
i  functions: deleting function helloWorld(us-central1)...
✔  functions[helloWorld(us-central1)]: Successful delete operation.
✔  functions[api(us-central1)]: Successful create operation.
Function URL (api): https://hogehoge.cloudfunctions.net/api

✔  Deploy complete!

Project Console: https://console.firebase.google.com/project/fir-todo-8868b/overview
</code></pre>
<ul>
<li>デプロイが完了しいたらリクエストしてみる．</li>
</ul>
<pre><code class="language-bash">$ curl https://hogehoge.cloudfunctions.net/api/hello
Hello Express!
</code></pre>
<p>これで動作 OK！</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="express-での値の受け取り"><a class="header" href="#express-での値の受け取り">Express での値の受け取り</a></h1>
<h2 id="url-のパラメータ取得"><a class="header" href="#url-のパラメータ取得">URL のパラメータ取得</a></h2>
<ul>
<li>
<p><code>/user/:userId</code>のように記述すると，値を受け取ることができる．</p>
</li>
<li>
<p>例えば，<code>https://hogehoge.cloudfunctions.net/api/user/2</code>のようにリクエストを送信すると，Express では<code>2</code>の文字列を取得することができる．</p>
</li>
<li>
<p>Express 内では<code>req.params.userId</code>のように取得する．</p>
</li>
<li>
<p><code>index.js</code>を以下のように編集する．</p>
</li>
</ul>
<pre><code class="language-js">const functions = require(&quot;firebase-functions&quot;);
const express = require(&quot;express&quot;);

const app = express();

app.get(&quot;/hello&quot;, (req, res) =&gt; {
  res.send(&quot;Hello Express!&quot;);
});

// ↓↓↓ エンドポイントを追加 ↓↓↓
app.get(&quot;/user/:userId&quot;, (req, res) =&gt; {
  const users = [
    { id: 1, name: &quot;ジョナサン&quot; },
    { id: 2, name: &quot;ジョセフ&quot; },
    { id: 3, name: &quot;承太郎&quot; },
    { id: 4, name: &quot;仗助&quot; },
    { id: 5, name: &quot;ジョルノ&quot; },
  ];
  // req.params.userIdでURLの後ろにつけた値をとれる．
  const targetUser = users.find(
    (user) =&gt; user.id === Number(req.params.userId)
  );
  res.send(targetUser);
});

// 以降変更なし
const api = functions.https.onRequest(app);
module.exports = { api };
</code></pre>
<h2 id="動作確認-1"><a class="header" href="#動作確認-1">動作確認</a></h2>
<ul>
<li>まずはローカルサーバーで動作確認</li>
</ul>
<pre><code class="language-bash">$ firebase serve
</code></pre>
<ul>
<li>ユーザ ID を指定してリクエスト送信</li>
</ul>
<pre><code class="language-bash">curl http://localhost:5000/cloudfunctions-3517c/us-central1/api/user/3
{&quot;id&quot;:3,&quot;name&quot;:&quot;承太郎&quot;}
</code></pre>
<blockquote>
<p>無料プランの場合はデプロイは飛ばしてください．</p>
</blockquote>
<ul>
<li>動作を確認したらデプロイ</li>
</ul>
<pre><code class="language-bash">$ firebase deploy
</code></pre>
<ul>
<li>デプロイしたらリクエスト送信</li>
</ul>
<pre><code class="language-bash">$ curl https://hogehoge.cloudfunctions.net/api/user/2
{&quot;id&quot;:2,&quot;name&quot;:&quot;ジョセフ&quot;}
$ curl https://hogehoge.cloudfunctions.net/api/user/5
{&quot;id&quot;:5,&quot;name&quot;:&quot;ジョルノ&quot;}
</code></pre>
<p>レスポンスが返ってくれば動作 OK．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="http-リクエストの実装"><a class="header" href="#http-リクエストの実装">http リクエストの実装</a></h1>
<ul>
<li>
<p>リクエスト受信時に値を取得できたので，取得した値を用いて Node.js から外部の API にリクエストを送る．</p>
</li>
<li>
<p>例によって Google books API を利用する．</p>
</li>
<li>
<p>Node.js から API へリクエストを送信することで，クライアントアプリケーションの処理を単純にすることができる．</p>
</li>
<li>
<p>web アプリでもネイティブアプリでも，Node.js のエンドポイントにリクエストを送信するだけで良い．</p>
</li>
</ul>
<h2 id="必要なモジュールのインストール"><a class="header" href="#必要なモジュールのインストール">必要なモジュールのインストール</a></h2>
<ul>
<li>
<p>Node.js の標準機能でも http リクエストを行えるが，記述が煩雑になるので<code>request</code>モジュールを利用する．</p>
</li>
<li>
<p>ついでに Promise を扱える<code>request-promise-native</code>もインストールする．</p>
</li>
<li>
<p>下記コマンドでインストール．</p>
</li>
</ul>
<pre><code class="language-bash">$ cd functions
$ npm install request
$ npm install request-promise-native
</code></pre>
<h2 id="リクエスト送信処理の追加"><a class="header" href="#リクエスト送信処理の追加">リクエスト送信処理の追加</a></h2>
<ul>
<li>
<p>Google books API へのリクエスト関数を定義．</p>
</li>
<li>
<p>エンドポイントを追加し，関数を実行．</p>
</li>
<li>
<p>API からのレスポンスをクライアントへ送信する．</p>
</li>
<li>
<p><code>index.js</code>を下記のように編集．</p>
</li>
</ul>
<pre><code class="language-js">// index.js
const functions = require(&quot;firebase-functions&quot;);
const express = require(&quot;express&quot;);
const requestPromise = require(&quot;request-promise-native&quot;); // 追加

const app = express();

// APIにリクエストを送る関数を定義
const getDataFromApi = async (keyword) =&gt; {
  // cloud functionsから実行する場合には地域の設定が必要になるため，`country=JP`を追加している
  const requestUrl =
    &quot;https://www.googleapis.com/books/v1/volumes?country=JP&amp;q=intitle:&quot;;
  const result = await requestPromise(`${requestUrl}${keyword}`);
  return result;
};

app.get(&quot;/hello&quot;, (req, res) =&gt; {
  res.send(&quot;Hello Express!&quot;);
});

app.get(&quot;/user/:userId&quot;, (req, res) =&gt; {
  // 省略
});

// エンドポイント追加
app.get(&quot;/gbooks/:keyword&quot;, async (req, res) =&gt; {
  // APIリクエストの関数を実行
  const response = await getDataFromApi(req.params.keyword);
  res.send(response);
});

const api = functions.https.onRequest(app);
module.exports = { api };
</code></pre>
<h2 id="動作確認デプロイ"><a class="header" href="#動作確認デプロイ">動作確認&amp;デプロイ</a></h2>
<ul>
<li>ローカルサーバーで確認．</li>
</ul>
<pre><code class="language-bash">$ firebase serve
</code></pre>
<ul>
<li>リクエスト送信（例として<code>keyword</code>に<code>node.js</code>を指定）</li>
</ul>
<pre><code class="language-bash">$ curl http://localhost:5000/cloudfunctions-3517c/us-central1/api/gbooks/node.js
↓のようなJSONデータがたくさん返ってくればOK
{
  &quot;kind&quot;: &quot;books#volume&quot;,
  &quot;id&quot;: &quot;fOgtAgAAQBAJ&quot;,
  &quot;etag&quot;: &quot;McoTnjan+uE&quot;,
  &quot;selfLink&quot;: &quot;https://www.googleapis.com/books/v1/volumes/fOgtAgAAQBAJ&quot;,
  &quot;volumeInfo&quot;: {
    &quot;title&quot;: &quot;Mastering Node.js&quot;,
    &quot;authors&quot;: [
      &quot;Sandro Pasquali&quot;
    ],
    &quot;publisher&quot;: &quot;Packt Publishing Ltd&quot;,
    &quot;publishedDate&quot;: &quot;2013-11-25&quot;,
    &quot;description&quot;: &quot;This book contains an extensive set of practical examples and an easy-to-follow approach to creating 3D objects.This book is great for anyone who already knows JavaScript and who wants to start creating 3D graphics that run in any browser. You don’t need to know anything about advanced math or WebGL; all that is needed is a general knowledge of JavaScript and HTML. The required materials and examples can be freely downloaded and all tools used in this book are open source.&quot;,
    &quot;industryIdentifiers&quot;: [
      {
        &quot;type&quot;: &quot;ISBN_13&quot;,
        &quot;identifier&quot;: &quot;9781782166337&quot;
      },
      {
        &quot;type&quot;: &quot;ISBN_10&quot;,
        &quot;identifier&quot;: &quot;1782166335&quot;
      }
    ],
    &quot;readingModes&quot;: {
      &quot;text&quot;: true,
      &quot;image&quot;: true
    },
    &quot;pageCount&quot;: 346,
    &quot;printType&quot;: &quot;BOOK&quot;,
    &quot;categories&quot;: [
      &quot;Computers&quot;
    ],
    &quot;maturityRating&quot;: &quot;NOT_MATURE&quot;,
    &quot;allowAnonLogging&quot;: true,
    &quot;contentVersion&quot;: &quot;2.2.2.0.preview.3&quot;,
    &quot;panelizationSummary&quot;: {
      &quot;containsEpubBubbles&quot;: false,
      &quot;containsImageBubbles&quot;: false
    },
    &quot;imageLinks&quot;: {
      &quot;smallThumbnail&quot;: &quot;http://books.google.com/books/content?id=fOgtAgAAQBAJ&amp;printsec=frontcover&amp;img=1&amp;zoom=5&amp;edge=curl&amp;source=gbs_api&quot;,
      &quot;thumbnail&quot;: &quot;http://books.google.com/books/content?id=fOgtAgAAQBAJ&amp;printsec=frontcover&amp;img=1&amp;zoom=1&amp;edge=curl&amp;source=gbs_api&quot;
    },
    &quot;language&quot;: &quot;en&quot;,
    &quot;previewLink&quot;: &quot;http://books.google.co.jp/books?id=fOgtAgAAQBAJ&amp;printsec=frontcover&amp;dq=intitle:node.js&amp;hl=&amp;cd=10&amp;source=gbs_api&quot;,
    &quot;infoLink&quot;: &quot;https://play.google.com/store/books/details?id=fOgtAgAAQBAJ&amp;source=gbs_api&quot;,
    &quot;canonicalVolumeLink&quot;: &quot;https://play.google.com/store/books/details?id=fOgtAgAAQBAJ&quot;
  },
  &quot;saleInfo&quot;: {
    &quot;country&quot;: &quot;JP&quot;,
    &quot;saleability&quot;: &quot;FOR_SALE&quot;,
    &quot;isEbook&quot;: true,
    &quot;listPrice&quot;: {
      &quot;amount&quot;: 3299,
      &quot;currencyCode&quot;: &quot;JPY&quot;
    },
    &quot;retailPrice&quot;: {
      &quot;amount&quot;: 2969,
      &quot;currencyCode&quot;: &quot;JPY&quot;
    },
    &quot;buyLink&quot;: &quot;https://play.google.com/store/books/details?id=fOgtAgAAQBAJ&amp;rdid=book-fOgtAgAAQBAJ&amp;rdot=1&amp;source=gbs_api&quot;,
    &quot;offers&quot;: [
      {
        &quot;finskyOfferType&quot;: 1,
        &quot;listPrice&quot;: {
          &quot;amountInMicros&quot;: 3299000000,
          &quot;currencyCode&quot;: &quot;JPY&quot;
        },
        &quot;retailPrice&quot;: {
          &quot;amountInMicros&quot;: 2969000000,
          &quot;currencyCode&quot;: &quot;JPY&quot;
        }
      }
    ]
  },
  &quot;accessInfo&quot;: {
    &quot;country&quot;: &quot;JP&quot;,
    &quot;viewability&quot;: &quot;PARTIAL&quot;,
    &quot;embeddable&quot;: true,
    &quot;publicDomain&quot;: false,
    &quot;textToSpeechPermission&quot;: &quot;ALLOWED&quot;,
    &quot;epub&quot;: {
      &quot;isAvailable&quot;: true
    },
    &quot;pdf&quot;: {
      &quot;isAvailable&quot;: true
    },
    &quot;webReaderLink&quot;: &quot;http://play.google.com/books/reader?id=fOgtAgAAQBAJ&amp;hl=&amp;printsec=frontcover&amp;source=gbs_api&quot;,
    &quot;accessViewStatus&quot;: &quot;SAMPLE&quot;,
    &quot;quoteSharingAllowed&quot;: false
  },
  &quot;searchInfo&quot;: {
    &quot;textSnippet&quot;: &quot;This book contains an extensive set of practical examples and an easy-to-follow approach to creating 3D objects.This book is great for anyone who already knows JavaScript and who wants to start creating 3D graphics that run in any browser.&quot;
  }
}
</code></pre>
<blockquote>
<p>無料プランの場合はデプロイは飛ばしてください．</p>
</blockquote>
<ul>
<li>動作確認したらデプロイ</li>
</ul>
<pre><code class="language-bash">$ firebase deploy
</code></pre>
<ul>
<li>
<p>ターミナルからリクエストを送る．</p>
</li>
<li>
<p>ローカルサーバのときと同様にいろいろ返ってくれば OK！</p>
</li>
</ul>
<pre><code class="language-bash">$ curl https://hogehoge.cloudfunctions.net/api/gbooks/react
うまくいっていればJSONデータが返ってくる
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cors-対策"><a class="header" href="#cors-対策">CORS 対策</a></h1>
<ul>
<li>
<p>ターミナルから<code>curl</code>コマンドでリクエストを送信すると正常に動作するが，クライアントアプリから<code>axios</code>などでリクエストを送信すると CORS エラーが発生する．</p>
</li>
<li>
<p>アプリケーションからも利用できるように，追加のモジュールをインストールする．</p>
</li>
</ul>
<pre><code class="language-bash">$ cd functions
$ npm install cors
</code></pre>
<h2 id="ファイル内全ての-api-について-cors-を許可したい場合"><a class="header" href="#ファイル内全ての-api-について-cors-を許可したい場合">ファイル内全ての API について CORS を許可したい場合</a></h2>
<ul>
<li>全部外部からのリクエストを許可する場合には下記のように追記すれば OK．</li>
</ul>
<pre><code class="language-js">// index.js
const functions = require(&quot;firebase-functions&quot;);
const express = require(&quot;express&quot;);
const requestPromise = require(&quot;request-promise-native&quot;);
const cors = require(&quot;cors&quot;); // 追加

const app = express();

app.use(cors()); // 追加

const getDataFromApi = async (keyword) =&gt; {
  // 省略
};

app.get(&quot;/hello&quot;, (req, res) =&gt; {
  // 省略
});

app.get(&quot;/user/:userId&quot;, (req, res) =&gt; {
  // 省略
});

app.get(&quot;/gbooks/:keyword&quot;, async (req, res) =&gt; {
  // 省略
});

const api = functions.https.onRequest(app);
module.exports = { api };
</code></pre>
<h2 id="個別の-api-について-cors-を許可したい場合"><a class="header" href="#個別の-api-について-cors-を許可したい場合">個別の API について CORS を許可したい場合</a></h2>
<ul>
<li>
<p>全部許可せずに，指定したエンドポイントのみアクセスを許可したい場合．</p>
</li>
<li>
<p>許可したいエンドポイントだけに追記を行う．</p>
</li>
</ul>
<pre><code class="language-js">// index.js
const functions = require(&quot;firebase-functions&quot;);
const express = require(&quot;express&quot;);
const requestPromise = require(&quot;request-promise-native&quot;);
const cors = require(&quot;cors&quot;); // 追加

const app = express();

// app.use(cors());  // 一旦コメントアウト

const getDataFromApi = async (keyword) =&gt; {
  // 省略
};

app.get(&quot;/hello&quot;, (req, res) =&gt; {
  // 省略
});

app.get(&quot;/user/:userId&quot;, (req, res) =&gt; {
  // 省略
});

// ここに`cors()`を追加
app.get(&quot;/gbooks/:keyword&quot;, cors(), async (req, res) =&gt; {
  // 省略
});

const api = functions.https.onRequest(app);
module.exports = { api };
</code></pre>
<ul>
<li>クライアントアプリケーションからリクエストを送信してデータが返ってくれば OK．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="課題"><a class="header" href="#課題">課題</a></h1>
<ul>
<li>
<p>cloud functions 上に任意の API を絡めた Node.js のアプリケーションをデプロイ．</p>
<ul>
<li>Firebase が無料プランの場合はローカルでの動作確認ができれば OK！</li>
</ul>
</li>
<li>
<p>ターミナルや postman からリクエストを送信して動作している状態になっていれば OK！</p>
</li>
<li>
<p>できる人はクライアントアプリを実装して連携させてみよう！</p>
</li>
</ul>
<p>今回はここまで( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="サーバ編-①nodejs-1"><a class="header" href="#サーバ編-①nodejs-1">サーバ編 ①（Node.js）</a></h1>
<h2 id="今回のゴール"><a class="header" href="#今回のゴール">今回のゴール</a></h2>
<ul>
<li>
<p>Node.js と Express で簡単な API を体験する．</p>
</li>
<li>
<p>実装のしかたを複数学び，見通しの良いコードの構造を把握する．</p>
</li>
<li>
<p>サーバで動作する「おみくじ」と「じゃんけん」を実装する．</p>
</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="nodejs-とは"><a class="header" href="#nodejs-とは">Node.js とは</a></h1>
<p>サーバで JavaScript を動かす環境のこと．
「Node.js」という言語があるわけではないので認識違いに注意．</p>
<h2 id="web-アプリケーションの仕組みapi-を実装する場合"><a class="header" href="#web-アプリケーションの仕組みapi-を実装する場合">Web アプリケーションの仕組み（API を実装する場合）</a></h2>
<p>基本は「リクエスト」と「レスポンス」．PHP など他の言語と同じ．</p>
<p>サーバ側でリクエストを受ける URI（Uniform Resource Identifier の略．URL とほぼ同義）を用意しておき，そこにクライアント（ブラウザなど）からリクエストを送信する．</p>
<p>リクエストを受けると記述されたコードが実行され，データなどが返される（JSON 形式が多い）．</p>
<h2 id="express"><a class="header" href="#express">Express</a></h2>
<p>Express は Node.js を用いて Web アプリケーションを構築するためのフレームワーク．</p>
<p>Node.js は自由度が非常に高く，そのまま書くと人によって千差万別となる．したがって，Web 開発をするときは Express を使用するのがデファクトスタンダードとなっている状態である（他にもフレームワークは存在するが，Express を基にしたものが多い）．</p>
<p>Express は構造が簡易であり，API の実装も非常に簡単である．今回は Express を使っていくつかの API を実装してみる．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api-実装の準備"><a class="header" href="#api-実装の準備">API 実装の準備</a></h1>
<p>Node.js のプロジェクトを実装し，動かしてみる．</p>
<h2 id="プロジェクト作成"><a class="header" href="#プロジェクト作成">プロジェクト作成</a></h2>
<p>プロジェクトを作成するには，下記のコマンドを実行する．</p>
<pre><code class="language-bash">$ mkdir express-project &amp;&amp; cd express-project
$ npm init
</code></pre>
<p><code>npm</code>は<code>node package module</code>の略であり，Node.js 上で動くパッケージを管理するツールである．Node.js で開発を行う場合はこれを用いることがほとんどである．</p>
<p>ダイアログが出てくるので，答えていく．全部そのまま Enter で OK．</p>
<pre><code class="language-bash">This utility will walk you through creating a package.json file.
It only covers the most common items, and tries to guess sensible defaults.

See `npm help init` for definitive documentation on these fields
and exactly what they do.

Use `npm install &lt;pkg&gt;` afterwards to install a package and
save it as a dependency in the package.json file.

Press ^C at any time to quit.
package name: (express-project)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to /home/taroosg/Desktop/express-project/package.json:

{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}


Is this OK? (yes)

</code></pre>
<p>完了したらエディタで開く．</p>
<p>エディタで開いたら<code>package.json</code>が作成されているので，中身を確認する．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>name</td><td>プロダクト名．</td></tr>
<tr><td>version</td><td>プロダクトのバージョン．</td></tr>
<tr><td>description</td><td>プロダクトの説明．</td></tr>
<tr><td>main</td><td>プロダクトをパッケージとして公開する場合に入り口となるファイルを指定する．</td></tr>
<tr><td>script</td><td>開発者が任意に作成するコマンド．</td></tr>
<tr><td>auther</td><td>開発者情報．1 人のみ記述する．</td></tr>
<tr><td>license</td><td>ライセンス情報．</td></tr>
</tbody></table>
<h2 id="packagejsonに追記"><a class="header" href="#packagejsonに追記"><code>package.json</code>に追記</a></h2>
<p>下記の内容を追記する．</p>
<pre><code class="language-json">&quot;type&quot;: &quot;module&quot;,
</code></pre>
<p>追記後は以下のような状態．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p><code>package.json</code>に<code>&quot;type&quot;: &quot;module&quot;</code>を追記することで<code>import</code>形式で別ファイルを読みこむことができる．
この追記を行わない場合，外部ファイルを読み込む際には<code>require()</code>関数を用いる．
React などでは<code>import</code>が基本となっており，こちらに揃えておいたほうがメリットが大きくオススメである．</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="expressのインストール"><a class="header" href="#expressのインストール">Expressのインストール</a></h1>
<p>今回は Express のフレームワークを使用するため，下記コマンドで</p>
<pre><code class="language-bash">$ npm i express
</code></pre>
<p>実行結果</p>
<pre><code class="language-bash">+ express@4.17.1
added 50 packages from 37 contributors and audited 50 packages in 1.687s
found 0 vulnerabilities

</code></pre>
<p>完了したら，再度<code>package.json</code>を開き，以下の内容が追加されていることを確認する．</p>
<pre><code class="language-json">&quot;dependencies&quot;: {
  &quot;express&quot;: &quot;^4.17.1&quot;
}

</code></pre>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>dependencies</td><td>このプロダクトが依存するパッケージの一覧．</td></tr>
</tbody></table>
<p><code>dependencies</code>の中にインストールしたパッケージが追加される仕組み．パッケージとはいろいろな機能をまとめてインストールできるようにしたものであり，様々なものが公開されている．ライブラリとほぼ同義．</p>
<p>また，インストールされたパッケージは同時に作成される<code>node_modules</code>ディレクトリ内に保存される．このディレクトリはパッケージ専用なので，自分で触ることは殆ど無い．</p>
<p><code>package-lock.json</code>には実際にインストールしたパッケージのバージョンが記載される．基本的に触らない．</p>
<p><code>package.json</code>にはプロダクトに必要なパッケージがすべて記載される．コマンド<code>npm install</code>を実行すると，ここに記載されたパッケージがすべてインストールされる．</p>
<p>プロダクトで使用されているライブラリなどを確認できるため，他の人が書いたコードを見るときもチェックすることをオススメ．</p>
<h2 id="gitignoreファイルの作成"><a class="header" href="#gitignoreファイルの作成"><code>.gitignore</code>ファイルの作成</a></h2>
<p>ソースコードを Git で管理することは周知のことであるが，プロジェクト内には Git で管理したくないファイルやディレクトリも存在する．</p>
<p>例えば，上記で作成された<code>node_modules</code>ディレクトリにはインストールしたパッケージだけでなく，「パッケージが必要としている別のパッケージ」もインストールされる．そのため，これらすべてを Git で管理するとファイル数が膨大になってしまう．</p>
<p>そのため，<code>node_modules</code>ディレクトリ（とその他 Git 管理したくないファイル）を<code>.gitignore</code>と呼ばれるファイルにリストアップすることで Git の管理外に措くことができる．</p>
<p>エディタで<code>.gitignore</code>を作成する．必ずプロジェクト直下に作成すること．</p>
<p>作成したら以下の内容を記述しよう．<code>.gitignore</code>から見た相対パスで Git 管理外にしたいファイルやディレクトリを指定している．</p>
<pre><code class="language-txt">/node_modules
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装1おみくじ初級編"><a class="header" href="#api実装1おみくじ初級編">API実装1（おみくじ初級編）</a></h1>
<h2 id="実行用ファイルの作成"><a class="header" href="#実行用ファイルの作成">実行用ファイルの作成</a></h2>
<p>実行するための<code>app.js</code>ファイルを作成する．エディタから作成すれば OK．</p>
<p>ファイルを作成したら下記の内容を記述する．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;

const app = express();
const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.send(&quot;Hello Node.js!&quot;);
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<p>上記のコードは<code>app.js</code>が実行されると，<code>http://localhost:3001</code>でサーバが立ち上がることを示している．</p>
<p>また，<code>http://localhost:3001/</code>に<code>GET</code>でリクエストが来ると，<code>Hello Node.js!</code>というレスポンスを返すよう記述している．</p>
<h2 id="動作確認-2"><a class="header" href="#動作確認-2">動作確認</a></h2>
<p>上記を記述したら，ターミナルで以下のコマンドを実行し，サーバを起動する．実行する際には作業ディレクトリに移動しておくこと．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>実行結果．下記のようにサーバが立ち上がれば成功．</p>
<pre><code class="language-bash">Example app listening at http://localhost:3001
</code></pre>
<p>立ち上がったら，別のターミナルで下記コマンドを実行し，リクエストとレスポンスが適切に処理されることを確認する．</p>
<p>コマンドを実行してメッセージが返ってくれば成功．</p>
<pre><code class="language-bash">$ curl localhost:3001
Hello Node.js!
</code></pre>
<p><code>curl</code>はターミナルから http リクエストを送るコマンド．インストールされていない場合はインストールしておく．</p>
<p>サーバを終了する場合は<code>ctrl + c</code>で終了できる．</p>
<h2 id="uri-の追加"><a class="header" href="#uri-の追加">URI の追加</a></h2>
<p><code>/</code>以外にも URI と作成してみる．</p>
<p><code>app.js</code>を以下のように編集する．<code>/omikuji</code>，<code>/janken</code>の 2 つの URI を追加し，各レスポンスを JSON 形式で返すよう変更している．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;

const app = express();
const port = 3001;

// 編集
app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

// 追加
app.get(&quot;/omikuji&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/omikuji&quot;,
    message: &quot;This is Omikuji URI!&quot;,
  });
});

// 追加
app.get(&quot;/janken&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/janken&quot;,
    message: &quot;This is Janken URI!&quot;,
  });
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="動作確認-3"><a class="header" href="#動作確認-3">動作確認</a></h2>
<p>記述したら，再度下記コマンドでサーバを立ち上げる．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>別のターミナルから，<code>curl</code>コマンドで動作を確認する．</p>
<pre><code class="language-bash">$ curl localhost:3001/
{&quot;uri&quot;:&quot;/&quot;,&quot;message&quot;:&quot;Hello Node.js!&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;This is Omikuji URI!&quot;}

$ curl localhost:3001/janken
{&quot;uri&quot;:&quot;/janken&quot;,&quot;message&quot;:&quot;This is Janken URI!&quot;}

</code></pre>
<p>簡単であるがこれだけで API を実装することができた．</p>
<h2 id="演習おみくじ処理の追加"><a class="header" href="#演習おみくじ処理の追加">【演習】おみくじ処理の追加</a></h2>
<p>実際におみくじの処理を追加してみよう．</p>
<p><code>app.js</code>の以下の部分におみくじの処理を書いて動作を確認しよう．サーバを起動し，以下のような結果になるように実装する．何回か実行して異なる結果が返ってくれば OK！</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;大吉&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;凶&quot;}

$ curl localhost:3001/omikuji
{&quot;uri&quot;:&quot;/omikuji&quot;,&quot;message&quot;:&quot;中吉&quot;}

</code></pre>
<p>実装例：</p>
<pre><code class="language-js">// app.js

// 省略

app.get(&quot;/omikuji&quot;, (req, res) =&gt; {
  const omikuji = [&quot;大吉&quot;, &quot;中吉&quot;, &quot;小吉&quot;, &quot;凶&quot;, &quot;大凶&quot;];
  const min = 0;
  const max = omikuji.length - 1;
  const index = Math.floor(Math.random() * (max - min + 1)) + min;
  res.json({
    uri: &quot;/omikuji&quot;,
    message: omikuji[index],
  });
});

// 省略

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="コマンドの追加"><a class="header" href="#コマンドの追加">コマンドの追加</a></h1>
<p>ここまで，下記コマンドでサーバを実行していた．</p>
<pre><code class="language-bash">$ node app.js
</code></pre>
<p>これとは別に，プロジェクトに対して自分でコマンドを作成することができる．</p>
<p>コマンドを追加する場合は<code>package.json</code>に記述する．下記の内容を追記してみよう．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;__comment&quot;: &quot;↓ここを追記（この行は書かなくてOK）&quot;,
    &quot;start&quot;: &quot;node app.js&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;^4.17.1&quot;
  }
}
</code></pre>
<p>このように記述すると，<code>npm start</code>というコマンドを実行すると<code>node app.js</code>が実行される．</p>
<p>プロジェクトが複雑になると，場面に応じて様々なコマンドを実行したい場合がある．そのようなときに，統一されたコマンドを準備しておくことで開発をスムーズに進めることができる．</p>
<p>下記を実行するとサーバが立ち上がる．これまでと同じ動作であることを確認しよう．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装2おみくじ中級編"><a class="header" href="#api実装2おみくじ中級編">API実装2（おみくじ中級編）</a></h1>
<p>簡単な API を実装するだけならば，ここまでの内容で十分である．おみくじの処理部分に適当な記述をすれば問題ないであろう．</p>
<p>しかし，コードの記述量が増えてくると，見通しが悪くなってしまい，保守管理にも支障をきたす．</p>
<p>そこで，処理中の役割毎に別ファイルに記述できるようにディレクトリ構成を変更する（責務の分離，などと呼ばれる）．</p>
<h2 id="ディレクトリ構造と役割"><a class="header" href="#ディレクトリ構造と役割">ディレクトリ構造と役割</a></h2>
<p>大きく<code>routes</code>，<code>controllers</code>，<code>services</code>の 3 つに分離する．DB などと組み合わせてデータを扱う場合は他に<code>model</code>を用意するが今回は省略する．</p>
<p>各要素の役割は以下の通り．</p>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>routes</td><td>URI と実行する処理の対応．</td></tr>
<tr><td>controllers</td><td>リクエストパラメータの検証，レスポンス送信．</td></tr>
<tr><td>services</td><td>リクエストに対する処理のメインロジックを記述．</td></tr>
<tr><td>repositories</td><td>DB関連の処理を記述．今回は出番なし．</td></tr>
</tbody></table>
<p>このような役割分担とするため，以下のようにディレクトリとファイルを作成する．</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   └── omikuji.controller.js
├── node_modules
├── package.json
├── package-lock.json
├── routes
│   └── omikuji.route.js
└── services
    └── omikuji.service.js

</code></pre>
<h2 id="実行ファイルの実装"><a class="header" href="#実行ファイルの実装">実行ファイルの実装</a></h2>
<p><code>app.js</code>を以下のように編集する．</p>
<p>ルーティングは routes 以下のファイルに任せ，指定したファイルを読み込むよう記述．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
// おみくじのrouterを読み込む
import { omikujiRouter } from &quot;./routes/omikuji.route.js&quot;;

const app = express();
const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

// おみくじのルーティングを変更
app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));

app.get(&quot;/janken&quot;, (req, res) =&gt; {
  res.json({ message: &quot;This is Janken URI!&quot; });
});

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="ルーティングの実装"><a class="header" href="#ルーティングの実装">ルーティングの実装</a></h2>
<p><code>routes/omikuji.route.js</code>に以下の内容を記述する．</p>
<p>URI と対応するコントローラの処理を記述する．</p>
<pre><code class="language-js">// routes/omikuji.route.js

import express from &quot;express&quot;;
import { getResult } from &quot;../controllers/omikuji.controller.js&quot;

export const omikujiRouter = express.Router();

omikujiRouter.get(&quot;/&quot;, (req, res) =&gt; getResult(req, res));

</code></pre>
<h2 id="コントローラの実装"><a class="header" href="#コントローラの実装">コントローラの実装</a></h2>
<p><code>controllers/omikuji.controller.js</code>に以下の内容を記述する．</p>
<p>サービスを呼び出して実行したいメソッドを指定し，結果によってレスポンスを指定する．</p>
<pre><code class="language-js">// controllers/omikuji.controller.js

import { getOmikuji } from &quot;../services/omikuji.service.js&quot;;

export const getResult = async (req, res, next) =&gt; {
  try {
    const result = await getOmikuji({});
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Omikuji!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの実装"><a class="header" href="#サービスの実装">サービスの実装</a></h2>
<p><code>services/omikuji.service.js</code>に以下の内容を記述する．</p>
<p>サービスでは実行したいロジックを書く．ここでおみくじのロジックを実装している．</p>
<pre><code class="language-js">// services/omikuji.service.js

export const getOmikuji = async (query) =&gt; {
  try {
    const omikuji = [&quot;大吉&quot;, &quot;中吉&quot;, &quot;小吉&quot;, &quot;凶&quot;, &quot;大凶&quot;];
    const min = 0;
    const max = omikuji.length - 1;
    const index = Math.floor(Math.random() * (max - min + 1)) + min;
    return { result: omikuji[index] };
  } catch (e) {
    throw Error(&quot;Error while getting Omikuji.&quot;);
  }
};

</code></pre>
<p>処理の順序としては以下のようになる．</p>
<pre><code class="language-txt">リクエスト               レスポンス
   ↓                       ↑
routes/omikuji.route.js    |
   ↓                       |
controllers/omikuji.controller.js
   ↓           ↑
ervices/omikuji.service.js

</code></pre>
<h2 id="動作確認-4"><a class="header" href="#動作確認-4">動作確認</a></h2>
<p>サーバを立ち上げ，以下のコマンドでリクエストを送信する．</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
</code></pre>
<p>おみくじの結果が返ってくれば成功．数回実行し，異なる結果が返ってくることを確認しておこう．</p>
<pre><code class="language-bash">$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;凶&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;大凶&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;中吉&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

$ curl localhost:3001/omikuji
{&quot;status&quot;:200,&quot;result&quot;:{&quot;result&quot;:&quot;大吉&quot;},&quot;message&quot;:&quot;Succesfully get Omikuji!&quot;}

</code></pre>
<p>ユーザに返すレスポンスを変更したい場合はコントローラを，処理の内容を更新したい場合はサービスを書き換えれば良い．このように，各責務を別の場所に置くことでメンテナンスしやすいプロダクトになる．</p>
<p>これでおみくじの実装は完了である．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="api実装3じゃんけん"><a class="header" href="#api実装3じゃんけん">API実装3（じゃんけん）</a></h1>
<p>おみくじの実装ができたので，ユーザ側からデータを送信してじゃんけんの結果を返す API を実装してみる．</p>
<h2 id="アプリケーションの全体像"><a class="header" href="#アプリケーションの全体像">アプリケーションの全体像</a></h2>
<p>ユーザはリクエスト時に<code>post</code>メソッドで自分の手を送信する．サーバ側はユーザから送信された手に対してランダムで手を出し，「ユーザの手」「サーバの手」「勝敗」をレスポンスで返却する．</p>
<p>下図を参考に，必要なファイルを作成する．</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   ├── janken.controller.js
│   └── omikuji.controller.js
├── node_modules
├── package.json
├── package-lock.json
├── routes
│   ├── janken.route.js
│   └── omikuji.route.js
└── services
    ├── janken.service.js
    └── omikuji.service.js

</code></pre>
<h2 id="各ファイルの実装"><a class="header" href="#各ファイルの実装">各ファイルの実装</a></h2>
<p><code>app.js</code>を以下のように編集する．</p>
<p>じゃんけんのルーティングを読み込む．また，POST メソッドでデータを受け取るためには<code>express.urlencoded({ extended: true })</code>とJSONデータの扱いで<code>express.json()</code>が必要になるため読み込んでいる．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
import { omikujiRouter } from &quot;./routes/omikuji.route.js&quot;;
// じゃんけんのルーティングを読み込む
import { jankenRouter } from &quot;./routes/janken.route.js&quot;;

const app = express();
// ↓POSTでデータを受け取るために必要
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

const port = 3001;

app.get(&quot;/&quot;, (req, res) =&gt; {
  res.json({
    uri: &quot;/&quot;,
    message: &quot;Hello Node.js!&quot;,
  });
});

app.use(&quot;/omikuji&quot;, (req, res) =&gt; omikujiRouter(req, res));
// じゃんけんのルーティングを追加
app.use(&quot;/janken&quot;, (req, res) =&gt; jankenRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});

</code></pre>
<h2 id="ルーティングの実装-1"><a class="header" href="#ルーティングの実装-1">ルーティングの実装</a></h2>
<p><code>routes/janken.route.js</code>に以下の内容を記述する．</p>
<p>URI と対応するコントローラの処理を記述する．今回は POST で受け取る点と送信されてきたデータが<code>req</code>に入っている点に注意．</p>
<pre><code class="language-js">// routes/janken.route.js

import express from &quot;express&quot;;
import { getResult } from &quot;../controllers/janken.controller.js&quot;;

export const jankenRouter = express.Router();

jankenRouter.post(&quot;/&quot;, (req, res) =&gt; getResult(req, res));

</code></pre>
<h2 id="コントローラの実装-1"><a class="header" href="#コントローラの実装-1">コントローラの実装</a></h2>
<p><code>controllers/janken.controller.js</code>に以下の内容を記述する．</p>
<p>おみくじの場合とほぼ同じ．</p>
<pre><code class="language-js">// controllers/janken.controller.js

import { getJanken } from &quot;../services/janken.service.js&quot;;

export const getResult = async (req, res, next) =&gt; {
  try {
    const result = await getJanken(req.body);
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Succesfully get Janken!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

</code></pre>
<h2 id="サービスの実装-1"><a class="header" href="#サービスの実装-1">サービスの実装</a></h2>
<p><code>services/janken.service.js</code>に以下の内容を記述する．</p>
<p>とりあえず毎回同じ結果を返している．</p>
<pre><code class="language-js">// services/janken.service.js

export const getJanken = async (query) =&gt; {
  try {
    return { yourHand: query.myhand, comHand: &quot;グー&quot;, result: &quot;テスト中&quot; };
  } catch (e) {
    throw Error(&quot;Error while getting Janken&quot;);
  }
};

</code></pre>
<h2 id="動作確認-5"><a class="header" href="#動作確認-5">動作確認</a></h2>
<p>サーバを立ち上げて，<code>curl</code>コマンドでリクエストを送信する．POST する場合は下記の書式で実行する．</p>
<p>結果が返ってくれば成功．</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;パー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;パー&quot;,&quot;comHand&quot;:&quot;グー&quot;,&quot;result&quot;:&quot;テスト中&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}
</code></pre>
<p>サーバに対して<code>{&quot;myhand&quot;:&quot;パー&quot;}</code>という JSON 形式のデータを POST メソッドで送信している．</p>
<h2 id="演習じゃんけんの実装"><a class="header" href="#演習じゃんけんの実装">【演習】じゃんけんの実装</a></h2>
<p>上記で記述した<code>services/janken.service.js</code>にじゃんけんのロジックを実装してみよう．</p>
<p>サーバを立ち上げて，以下のようにじゃんけんができれば OK！</p>
<pre><code class="language-js">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;グー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;グー&quot;,&quot;comHand&quot;:&quot;チョキ&quot;,&quot;result&quot;:&quot;Win&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;チョキ&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;チョキ&quot;,&quot;comHand&quot;:&quot;パー&quot;,&quot;result&quot;:&quot;Win&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;パー&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;yourHand&quot;:&quot;パー&quot;,&quot;comHand&quot;:&quot;チョキ&quot;,&quot;result&quot;:&quot;Lose&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

</code></pre>
<p>じゃんけんができたら，グーチョキパー以外の手を送信すると NG なメッセージが返す実装にもチャレンジ！</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;myhand&quot;:&quot;無敵のアレ&quot;}' localhost:3001/janken

{&quot;status&quot;:200,&quot;result&quot;:{&quot;message&quot;:&quot;Invalid hand...&quot;},&quot;message&quot;:&quot;Succesfully get Janken!&quot;}

</code></pre>
<p>実装例：</p>
<pre><code class="language-js">// services/janken.service.js

export const getJanken = async (query) =&gt; {
  try {
    const hand = [&quot;グー&quot;, &quot;チョキ&quot;, &quot;パー&quot;];
    const myIndex = hand.indexOf(query.myhand);
    if (myIndex === -1) return { message: &quot;Invalid hand...&quot; };
    const comIndex = Math.floor(Math.random() * 3);
    const resultSheet = [
      [&quot;Draw&quot;, &quot;Win&quot;, &quot;Lose&quot;],
      [&quot;Lose&quot;, &quot;Draw&quot;, &quot;Win&quot;],
      [&quot;Win&quot;, &quot;Lose&quot;, &quot;Draw&quot;],
    ];
    return {
      yourHand: query.myhand,
      comHand: hand[comIndex],
      result: resultSheet[myIndex][comIndex],
    };
  } catch (e) {
    throw Error(&quot;Error while getting Janken&quot;);
  }
};

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ"><a class="header" href="#まとめ">まとめ</a></h1>
<p>今回は Node.js を用いて API サーバを実装してみた．</p>
<p>おみくじやじゃんけんの実装を通じて，必要な処理に含まれる責務を分離し，別々のファイルに実装した．</p>
<p>Node.js はシンプルな構成で柔軟な API を構築できる魅力的な技術である．興味を持った方は，じゃんけんの勝率変更や DB 連携などにも挑戦してみると良いだろう．</p>
<p>今回は以上である( `･ω･)b</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="サーバ編-②nodejs"><a class="header" href="#サーバ編-②nodejs">サーバ編 ②（Node.js）</a></h1>
<h2 id="今回のゴール-1"><a class="header" href="#今回のゴール-1">今回のゴール</a></h2>
<ul>
<li>
<p>Supabase を用いたデータの永続化を実装する．</p>
</li>
<li>
<p>「todo リスト」を実装し，CRUD 処理とデータの構造を把握する．</p>
</li>
<li>
<p>Slack と連携する処理を実装する．</p>
</li>
</ul>
<h2 id="サーバ---クライアント型のアプリケーション"><a class="header" href="#サーバ---クライアント型のアプリケーション">サーバ - クライアント型のアプリケーション</a></h2>
<h3 id="サーバで動作する言語サーバサイド"><a class="header" href="#サーバで動作する言語サーバサイド">サーバで動作する言語（サーバサイド）</a></h3>
<p>サーバ上でプログラムが実行される．</p>
<p><img src="api-02/./img/php_web_server.svg" alt="サーバサイド言語の動き方" /></p>
<ul>
<li>
<p>PHP</p>
</li>
<li>
<p>Ruby</p>
</li>
<li>
<p>Python</p>
</li>
<li>
<p>JAVA</p>
</li>
<li>
<p>Node.js</p>
</li>
<li>
<p>etc...</p>
</li>
</ul>
<h2 id="サーバサイドの役割"><a class="header" href="#サーバサイドの役割">サーバサイドの役割</a></h2>
<p>様々な Web アプリケーションが存在するが，基本のサーバサイド処理は同様である．</p>
<p>基本の機能は何らかのデータを扱うことである．</p>
<h3 id="例"><a class="header" href="#例">例</a></h3>
<ul>
<li>
<p>twitter =&gt; ツイート，検索，タイムラインの表示，etc</p>
</li>
<li>
<p>facebook =&gt; 投稿，検索，記事の更新，コメント，etc</p>
</li>
<li>
<p>wordpress =&gt; ブログ記事の投稿，編集，削除，etc</p>
</li>
</ul>
<h3 id="-key-point"><a class="header" href="#-key-point">💡 Key Point</a></h3>
<blockquote>
<p>上記の処理は以下の 4 つに集約される．</p>
<ul>
<li>
<p>📝 データの「作成」（Create）</p>
</li>
<li>
<p>📖 データの「参照」（Read）</p>
</li>
<li>
<p>🔄 データの「更新」（Update）</p>
</li>
<li>
<p>🗑 データの「削除」（Delete）</p>
</li>
</ul>
</blockquote>
<p>これら 4 種類の処理の頭文字をとって「CRUD」と呼ぶ．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="データの永続化について"><a class="header" href="#データの永続化について">データの永続化について</a></h1>
<h2 id="nodejs-におけるデータ永続化"><a class="header" href="#nodejs-におけるデータ永続化">Node.js におけるデータ永続化</a></h2>
<p>データの永続化とは，アプリケーションの状態によらずデータを保持することである．言い換えると，DB などの外部にデータを保存すること．</p>
<p>データの永続化に使用する外部 DB は次のようなものがある．Node.js ではいずれの DB も利用できるが，RDB であれば MySQL か PostgreSQL，NoSQL では MongoDB，Firebase，Redis などがよく用いられる．</p>
<h2 id="rdb"><a class="header" href="#rdb">RDB</a></h2>
<p>SQL を用いてデータ管理を行う DB．柔軟な集計や結合ができ，情報も多い．</p>
<p>基本的には同じ SQL を記述すれば同じ動作が実行されるが，それぞれの DB で仕様が異なる部分もあるので使用前は要チェックすべし．</p>
<p>できることは非常に幅広く，データを扱う上でできないことはほぼないと考えて良い．</p>
<h3 id="例-1"><a class="header" href="#例-1">例</a></h3>
<ul>
<li>
<p>MySQL</p>
</li>
<li>
<p>PostgreSQL</p>
</li>
<li>
<p>OracleDB</p>
</li>
</ul>
<h2 id="nosql"><a class="header" href="#nosql">NoSQL</a></h2>
<p>Not Only SQL．SQL を前提としたデータ構造に縛られない DB．「値」およびそれを取得するための「キー」だけを格納できる Key-Value 型の DB などが代表的だ．</p>
<p>下記の例においてもそれぞれデータ構造が異なるため，プロジェクトの目的に合致した DB を選択する必要がある．</p>
<p>RDB と比較して後発のためにより直感的に扱えるものが多い一方で，データの格納および取得が高度に最適化されているが故に，機能性を最小限にしているものもある．</p>
<ul>
<li>
<p>MongoDB</p>
</li>
<li>
<p>Firebase Firestore Database</p>
</li>
<li>
<p>Firebase Realtime Database</p>
</li>
<li>
<p>Redis</p>
</li>
<li>
<p>DynamoDB</p>
</li>
<li>
<p>Neo4j</p>
</li>
<li>
<p>Supabase</p>
</li>
</ul>
<h2 id="使い分け"><a class="header" href="#使い分け">使い分け</a></h2>
<p>ケースバイケース．</p>
<p>アプリケーションが実現したい機能を明確にし，相性が良い方を選択する．</p>
<h2 id="今回使用する-db"><a class="header" href="#今回使用する-db">今回使用する DB</a></h2>
<p><strong>今回は環境構築が不要でオンラインにデータを保存できる「Supabase」を使用する．</strong></p>
<p>GitHub アカウントで使用できる．特徴は以下のとおり．</p>
<ul>
<li>
<p>オンライン上にデータを保存できる．</p>
</li>
<li>
<p>DB の構成がテーブル管理であるため NoSQL の中では RDB に近く，SQL ライクな操作ができる．</p>
<ul>
<li>PostgreSQL が元．</li>
</ul>
</li>
<li>
<p>DB 以外にも Auth，Storage など利用可能．</p>
</li>
<li>
<p>各種言語やフレームワーク用のライブラリが充実しており開発がしやすい（個人の感想）．</p>
</li>
</ul>
<p>ドキュメント</p>
<p><a href="https://supabase.com/docs">https://supabase.com/docs</a></p>
<p>注意点</p>
<ul>
<li>無料プランでは 1 週間で DB が止まる（管理画面から再起動可能）．</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="supabase-の準備"><a class="header" href="#supabase-の準備">Supabase の準備</a></h1>
<h2 id="supabase-の準備-1"><a class="header" href="#supabase-の準備-1">Supabase の準備</a></h2>
<p>今回は NoSQL である Supabase を用いて CRUD 処理を実装してみる．</p>
<p>DB がオンライン上にあるので，環境問わず使えるところが魅力．</p>
<h2 id="db-の作成"><a class="header" href="#db-の作成">DB の作成</a></h2>
<h3 id="プロジェクト作成-1"><a class="header" href="#プロジェクト作成-1">プロジェクト作成</a></h3>
<p>Supabase のコンソール（<a href="https://app.supabase.io/">https://app.supabase.io/</a>）にアクセスし，GitHub アカウントでサインインする．</p>
<p>「New project」をクリックし，project を作成する．</p>
<p><img src="api-02/./img/supabase-01.png" alt="Supabaseプロジェクト作成" /></p>
<p>プロジェクト名と DB アクセス用パスワードを設定する．面倒なパスワードを作成しないといけないので注意．</p>
<blockquote>
<p>パスワードの条件はよくわからないが，以下の文字列でクリアできる．</p>
<p><code>QwertyZxcvbn102938-_</code></p>
</blockquote>
<p><img src="api-02/./img/supabase-02.png" alt="Supabaseプロジェクト詳細" /></p>
<h3 id="テーブルの作成"><a class="header" href="#テーブルの作成">テーブルの作成</a></h3>
<p>「左側の Table アイコン」→「Create a new table」の順にクリックし，テーブルを作成する．</p>
<p>テーブル名：<code>todo_table</code></p>
<p>カラム：以下のとおり設定</p>
<table><thead><tr><th>Name</th><th>Type</th><th>備考</th></tr></thead><tbody>
<tr><td><code>id</code></td><td><code>int8</code></td><td>初期設定のまま</td></tr>
<tr><td><code>user_id</code></td><td><code>int8</code></td><td>追加</td></tr>
<tr><td><code>todo</code></td><td><code>varchar</code></td><td>追加</td></tr>
<tr><td><code>deadline</code></td><td><code>date</code></td><td>追加</td></tr>
<tr><td><code>is_done</code></td><td><code>bool</code></td><td>初期値は <code>false</code></td></tr>
<tr><td><code>created_at</code></td><td><code>timestampz</code></td><td>初期設定のまま</td></tr>
<tr><td><code>updated_at</code></td><td><code>timestampz</code></td><td><code>created-at</code> と同様</td></tr>
</tbody></table>
<h2 id="nodejs-側の準備"><a class="header" href="#nodejs-側の準備">Node.js 側の準備</a></h2>
<p>まず適当な場所で以下のコマンドを実行する．<code>express-202203</code> はプロジェクトのディレクトリ名なので各自で設定して OK．</p>
<pre><code class="language-bash">$ mkdir express-202203
$ cd express-202203
$ npm init -y
</code></pre>
<p><code>express-202203</code> ディレクトリをエディタで開き，今回の実装で必要なディレクトリとファイル（以下）を作成しておく．</p>
<ul>
<li>
<p><code>app.js</code></p>
</li>
<li>
<p><code>routes/todo.route.js</code></p>
</li>
<li>
<p><code>controllers/todo.controller.js</code></p>
</li>
<li>
<p><code>services/todo.service.js</code></p>
</li>
<li>
<p><code>repositories/todo.repository.js</code></p>
</li>
</ul>
<p>下記のような構成となっていれば OK！</p>
<pre><code class="language-bash">.
├── app.js
├── controllers
│   └── todo.controller.js
├── package.json
├── routes
│   └── todo.route.js
└── services
    └── todo.service.js

</code></pre>
<h2 id="packagejson-の編集"><a class="header" href="#packagejson-の編集"><code>package.json</code> の編集</a></h2>
<p>下記 2 点の内容を追記する．</p>
<pre><code class="language-json">&quot;type&quot;: &quot;module&quot;,
</code></pre>
<p>↓ こちらは <code>&quot;scripts&quot;</code> 内に記述する．</p>
<pre><code class="language-json">&quot;start&quot;: &quot;node app.js&quot;,
</code></pre>
<p>追記後は以下のような状態．</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;express-202203&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;type&quot;: &quot;module&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node app.js&quot;,
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  },
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
</code></pre>
<blockquote>
<p><strong>💡 Key Point</strong></p>
<p><code>package.json</code>に<code>&quot;type&quot;: &quot;module&quot;</code>を追記することで<code>import</code>形式で別ファイルを読みこむことができる．
この追記を行わない場合，外部ファイルを読み込む際には<code>require()</code>関数を用いる．
React などでは<code>import</code>が基本となっており，こちらに揃えておいたほうがメリットが大きくオススメである．</p>
</blockquote>
<h2 id="nodejs-と-supabase-の連携"><a class="header" href="#nodejs-と-supabase-の連携">Node.js と Supabase の連携</a></h2>
<ol>
<li>Supabase の管理画面から「<code>⚙</code>」→「<code>API</code>」の順にクリックする．</li>
<li><code>Project API keys</code> と <code>Config</code> の <code>URL</code> が必要になるので確認する．</li>
</ol>
<p><img src="api-02/./img/supabase-03.png" alt="Supabaseアクセス情報" /></p>
<ol start="3">
<li>プロジェクト直下に <code>.env</code> ファイルを作成し，以下の内容を記述する．これらの情報は機密情報なので環境変数を用いて管理する．</li>
</ol>
<pre><code class="language-txt">SUPABASE_API_KEY=`2で確認したAPI key`
SUPABASE_URL=`2で確認したURL`
</code></pre>
<ol start="4">
<li>以下のコマンドを実行し，環境変数を使用するためのライブラリをインストールする．</li>
</ol>
<pre><code class="language-bash">$ npm i dotenv
</code></pre>
<ol start="5">
<li>プロジェクト直下に <code>.gitignore</code> を作成し，に以下の内容を追記して <code>.env</code> ファイルを Git 管理外にする．</li>
</ol>
<pre><code>/node_modules
.env
</code></pre>
<ol start="6">
<li>下記コマンドを実行し，Node.js から Supabase を扱うためのライブラリをインストールする．</li>
</ol>
<pre><code class="language-bash">$ npm i @supabase/supabase-js
</code></pre>
<p>ここまででアプリケーションと Supabase を連携させる準備は完了．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ファイル作成と動作確認"><a class="header" href="#ファイル作成と動作確認">ファイル作成と動作確認</a></h1>
<h2 id="ルーティング表"><a class="header" href="#ルーティング表">ルーティング表</a></h2>
<p>これから実装していく機能は以下のとおり．基本的な CRUD 処理を実装する．</p>
<table><thead><tr><th>URI</th><th>method</th><th>name</th><th>description</th></tr></thead><tbody>
<tr><td><code>/todo</code></td><td>GET</td><td>findAll</td><td>データ全件取得</td></tr>
<tr><td><code>/todo/today</code></td><td>GET</td><td>find</td><td>本日締切のデータ取得</td></tr>
<tr><td><code>/todo</code></td><td>POST</td><td>store</td><td>データ作成処理</td></tr>
<tr><td><code>/todo/:id</code></td><td>PUT</td><td>update</td><td>データ更新処理</td></tr>
<tr><td><code>/todo/:id</code></td><td>DELETE</td><td>destroy</td><td>データ削除処理</td></tr>
</tbody></table>
<h2 id="役割分担"><a class="header" href="#役割分担">役割分担</a></h2>
<p>補足資料の役割分担表も参照．今回は repository に DB 関連の処理を実装する．</p>
<p>repository に DB 関連の処理を任せることで，DB が変更された場合でも他のコードの影響せずに運用することができる．このような役割分担をリポジトリパターンと呼ぶ．</p>
<table><thead><tr><th>項目</th><th>意味合い</th></tr></thead><tbody>
<tr><td>routes</td><td>URI と実行する処理の対応．</td></tr>
<tr><td>controllers</td><td>リクエストパラメータの検証，レスポンス送信．</td></tr>
<tr><td>services</td><td>リクエストに対する処理のメインロジックを記述．</td></tr>
<tr><td>repositories</td><td>DB 関連の処理を記述．今回は Supabase とやり取りする処理を記述する．</td></tr>
</tbody></table>
<h2 id="実装"><a class="header" href="#実装">実装</a></h2>
<p>まず下記コマンドで express をインストールする．</p>
<pre><code class="language-bash">$ npm i express
</code></pre>
<p>続いて，<code>app.js</code> に以下の内容を記述する．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
import { todoRouter } from &quot;./routes/todo.route.js&quot;;

const app = express();
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
const port = 3000;

app.use(&quot;/todo&quot;, (req, res) =&gt; todoRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});
</code></pre>
<p>まずそれぞれのファイルが連携できることを確認するため，DB と接続せずに固定のデータを返す処理を実装する．</p>
<h2 id="ルーティングの作成"><a class="header" href="#ルーティングの作成">ルーティングの作成</a></h2>
<p>まずはルーティングを作成．</p>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
import { readAllTodoData } from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成"><a class="header" href="#コントローラの作成">コントローラの作成</a></h2>
<p>コントローラではリクエストとレスポンスを定義．</p>
<pre><code class="language-js">// controllers/todo.controller.js

import { getAllTodoData } from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  try {
    const result = await getAllTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully get All Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成"><a class="header" href="#サービスの作成">サービスの作成</a></h2>
<p>サービスではリポジトリの関数（<code>findAll()</code>）を呼び出す．</p>
<pre><code class="language-js">// services/todo.service.js

import { findAll } from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  try {
    return await findAll();
  } catch (e) {
    throw Error(&quot;Error while getting All Todo Data&quot;);
  }
};
</code></pre>
<h2 id="リポジトリの作成"><a class="header" href="#リポジトリの作成">リポジトリの作成</a></h2>
<p>リポジトリは一旦決まったメッセージを返す．</p>
<pre><code class="language-js">// repositories/todo.repository.js

export const findAll = () =&gt; {
  return { message: &quot;OK&quot; };
};
</code></pre>
<h2 id="動作確認-6"><a class="header" href="#動作確認-6">動作確認</a></h2>
<p>動作確認する．サーバを立ち上げる．</p>
<pre><code class="language-bash">$ npm start
</code></pre>
<p>別ターミナルで以下のコマンドを実行し，下記のレスポンスが返ってくれば OK．</p>
<p>ブラウザで <code>localhost:3000/todo</code> にアクセスして確認しても OK．</p>
<pre><code class="language-bash">$ curl localhost:3000/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;message&quot;: &quot;OK&quot;
  },
  &quot;message&quot;: &quot;Successfully get All Todo Data!&quot;
}

</code></pre>
<p>一通りの動作が確認できたら，続いて Supabase の CRUD 処理を作成していく．</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="create-の処理"><a class="header" href="#create-の処理">Create の処理</a></h1>
<h2 id="create-処理の流れ"><a class="header" href="#create-処理の流れ">Create 処理の流れ</a></h2>
<p>はじめは Create の処理を実装する．クライアントから送信されたデータを DB に保存する一連の流れを書く．</p>
<p>今回は<code>POST</code>メソッドでデータを送信し，新規レコードを作成する．</p>
<h2 id="ルーティングの作成-1"><a class="header" href="#ルーティングの作成-1">ルーティングの作成</a></h2>
<p>ルーティングでは，collection 名とデータを受け取り，コントローラにデータを渡す．</p>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
// 🔽 編集
import {
  readAllTodoData,
  createTodoData,
} from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
// 🔽 追加
todoRouter.post(&quot;/&quot;, (req, res) =&gt; createTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-1"><a class="header" href="#コントローラの作成-1">コントローラの作成</a></h2>
<p>コントローラでは，データを整理してサービスに渡す．また，サービスの処理結果を元にレスポンスを返す．</p>
<pre><code class="language-js">// controllers/todo.controller.js

// 🔽 編集
import { getAllTodoData, insertTodoData } from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  // 省略
};

// 🔽 追加
export const createTodoData = async (req, res, next) =&gt; {
  try {
    const { todo, deadline, user_id } = req.body;
    if (!(todo &amp;&amp; deadline &amp;&amp; user_id)) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await insertTodoData({
      params: { todo: todo, deadline: deadline, user_id: Number(user_id) },
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully post Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成-1"><a class="header" href="#サービスの作成-1">サービスの作成</a></h2>
<p>サービスではロジックが必要な場合は記述するが，今回はデータをそのまま渡すだけ．実際に Supabase にデータを保存する処理は <code>repositories</code> レイヤーに分割する．</p>
<pre><code class="language-js">// services/todo.service.js

// 🔽 編集
import { findAll, store } from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  // 省略
};

// 🔽 追加
export const insertTodoData = async ({ params }) =&gt; {
  try {
    return await store({ params });
  } catch (e) {
    throw Error(&quot;Error while posting Todo Data&quot;);
  }
};
</code></pre>
<h2 id="リポジトリの作成-1"><a class="header" href="#リポジトリの作成-1">リポジトリの作成</a></h2>
<p>テーブルを指定してデータを保存する処理を実装する．ここで Supabase 関連のコードを記述する必要があるため，関連するコードを import する．</p>
<p>データ永続化に関するコードをリポジトリのレイヤーに閉じ込めることで，DB の種類が変更された場合にもコントローラやサービスのコードに影響ない状態にすることができる．</p>
<p>ポイントは以下のとおり．</p>
<ul>
<li>
<p><code>dotenv</code> で環境変数を読み込む．</p>
</li>
<li>
<p><code>createClient</code> で Supabase との連携を確立する．</p>
</li>
<li>
<p><code>insert()</code> でデータを作成する．</p>
</li>
<li>
<p><code>created_at</code>と<code>updated_at</code>は Supabase 側で初期値（現在日時）を設定しているため投稿不要．</p>
</li>
</ul>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/insert">https://supabase.com/docs/reference/javascript/insert</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

export const findAll = () =&gt; {
  return { message: &quot;OK&quot; };
};

export const store = async ({ params }) =&gt; {
  try {
    const { data, error } = await supabase.from(&quot;todo_table&quot;).insert([
      {
        ...params,
        is_done: false,
      },
    ]);
    return data;
  } catch (e) {
    throw Error(&quot;Error while store Todo Data&quot;);
  }
};
</code></pre>
<h2 id="動作確認-7"><a class="header" href="#動作確認-7">動作確認</a></h2>
<p>処理を追加したら動作確認する．<strong>サーバを再起動して</strong>，別ターミナルで下記コマンドでデータを送信し，成功のレスポンスが返ってくれば OK．</p>
<pre><code class="language-bash">$ curl -X POST -H &quot;Content-Type: application/json&quot; -d '{&quot;todo&quot;:&quot;node.js&quot;,&quot;user_id&quot;:1,&quot;deadline&quot;:&quot;2021-12-31&quot;}' localhost:3000/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 1,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-31&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully post Todo Data!&quot;
}

</code></pre>
<p>また，ブラウザで Supabase のコンソール画面からテーブルにアクセスし，送信したデータが保存されていることを確認しておく．</p>
<p>動作が確認できたら，2-3 件データを入れておこう．<strong>日付は本日含め適当に設定して複数件入れておく．</strong></p>
<p><img src="api-02/./img/supabase-04.png" alt="Supabase データ保存確認" /></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="read-の処理全件"><a class="header" href="#read-の処理全件">Read の処理（全件）</a></h1>
<h2 id="データ全件取得の処理"><a class="header" href="#データ全件取得の処理">データ全件取得の処理</a></h2>
<p>Read の処理では，ルーティングとコントローラとサービスははじめにつくったものを使用する．</p>
<p>リポジトリに以下の内容を記述する．テーブルを指定してデータをすべて取得する．<code>order()</code> を使用してデータを並び替えることができる．</p>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/using-modifiers">https://supabase.com/docs/reference/javascript/using-modifiers</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

// 🔽 編集
export const findAll = async () =&gt; {
  try {
    const { data, error } = await supabase
      .from(&quot;todo_table&quot;)
      .select()
      .order(&quot;deadline&quot;, { ascending: true })
      .order(&quot;todo&quot;, { ascending: true });
    return data;
  } catch (e) {
    throw Error(&quot;Error while getting Todo Data&quot;);
  }
};

export const store = async ({ params }) =&gt; {
  // 省略
};
</code></pre>
<h2 id="動作確認全件取得"><a class="header" href="#動作確認全件取得">動作確認（全件取得）</a></h2>
<p>記述したら動作確認する．下記コマンドを実行して，保存されているデータが全件取得できれば OK（下記はデータ 2 件登録時の例）．</p>
<pre><code class="language-bash">$ curl localhost:3000/todo

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 2,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;react&quot;,
      &quot;deadline&quot;: &quot;2021-12-21&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-16T06:23:58.614838+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:23:58.614838+00:00&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-31&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully get All Todo Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="read-の処理本日以前"><a class="header" href="#read-の処理本日以前">Read の処理（本日以前）</a></h1>
<h2 id="本日締切のデータだけを取得する処理"><a class="header" href="#本日締切のデータだけを取得する処理">本日締切のデータだけを取得する処理</a></h2>
<p>前項でデータを全件取得する処理を実装したので，次は条件をつけてデータを取得する処理を実装する．</p>
<p><code>deadline</code> カラムの値を参照し，「実行した日と同じかそれ以前」のデータのみ取得する．</p>
<h2 id="ルーティングの作成-2"><a class="header" href="#ルーティングの作成-2">ルーティングの作成</a></h2>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
// 🔽 編集
import {
  readAllTodoData,
  readTodayTodoData,
  createTodoData,
} from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
// 🔽 追加
todoRouter.get(&quot;/today&quot;, (req, res) =&gt; readTodayTodoData(req, res));
todoRouter.post(&quot;/&quot;, (req, res) =&gt; createTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-2"><a class="header" href="#コントローラの作成-2">コントローラの作成</a></h2>
<p>URL に付加した id を<code>req.params.id</code>で取得する．サービスに id を渡す．</p>
<pre><code class="language-js">// controllers/todo.controller.js

// 🔽 編集
import {
  getAllTodoData,
  getTodayTodoData,
  insertTodoData,
} from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  // 省略
};

// 🔽 追加
export const readTodayTodoData = async (req, res, next) =&gt; {
  try {
    const result = await getTodayTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully get Today Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

export const createTodoData = async (req, res, next) =&gt; {
  // 省略
};
</code></pre>
<h2 id="サービスの作成-2"><a class="header" href="#サービスの作成-2">サービスの作成</a></h2>
<p>今回は特にロジックなし．</p>
<pre><code class="language-js">// services/todo.service.js

// 🔽 編集
import { findAll, findToday, store } from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  // 省略
};

// 🔽 追加
export const getTodayTodoData = async () =&gt; {
  try {
    return await findToday();
  } catch (e) {
    throw Error(&quot;Error while getting Today Todo Data&quot;);
  }
};

export const insertTodoData = async ({ params }) =&gt; {
  // 省略
};
</code></pre>
<h2 id="リポジトリの作成-2"><a class="header" href="#リポジトリの作成-2">リポジトリの作成</a></h2>
<p><code>deadline</code> のカラムで条件を指定する．</p>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/using-filters">https://supabase.com/docs/reference/javascript/using-filters</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

export const findAll = async () =&gt; {
  // 省略
};

// 🔽 追加
export const findToday = async () =&gt; {
  try {
    const { data, error } = await supabase
      .from(&quot;todo_table&quot;)
      .select()
      .lte(&quot;deadline&quot;, new Date().toISOString())
      .order(&quot;deadline&quot;, { ascending: true })
      .order(&quot;todo&quot;, { ascending: true });
    return data;
  } catch (e) {
    throw Error(&quot;Error while getting Todo Data&quot;);
  }
};

export const store = async ({ params }) =&gt; {
  // 省略
};
</code></pre>
<h2 id="動作確認1-件取得"><a class="header" href="#動作確認1-件取得">動作確認（1 件取得）</a></h2>
<p>下記コマンドで動作をチェック．<code>deadline</code> が実行した日以前のデータが取得できれば OK．</p>
<pre><code class="language-bash">$ curl localhost:3000/todo/today

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 7,
      &quot;user_id&quot;: 2,
      &quot;todo&quot;: &quot;react&quot;,
      &quot;deadline&quot;: &quot;2021-12-04&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-06T06:31:13.794412+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-06T06:31:13.794412+00:00&quot;
    },
    {
      &quot;id&quot;: 6,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-06&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-06T06:30:24.275881+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-06T06:30:24.275881+00:00&quot;
    },
    {
      &quot;id&quot;: 1,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;test&quot;,
      &quot;deadline&quot;: &quot;2021-12-06&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-06T06:26:57.344976+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-06T06:26:57.344976+00:00&quot;
    },
    {
      &quot;id&quot;: 8,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;zoom meeting&quot;,
      &quot;deadline&quot;: &quot;2021-12-07&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-07T04:16:41.726675+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-07T04:16:41.726675+00:00&quot;
    },
    {
      &quot;id&quot;: 2,
      &quot;user_id&quot;: 2,
      &quot;todo&quot;: &quot;Nest.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-15&quot;,
      &quot;is_done&quot;: true,
      &quot;created_at&quot;: &quot;2021-12-06T06:27:33.388245+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-06T08:27:11.024+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully get Today Todo Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="update-の処理"><a class="header" href="#update-の処理">Update の処理</a></h1>
<h2 id="データ更新の処理"><a class="header" href="#データ更新の処理">データ更新の処理</a></h2>
<p>既存のデータを上書きする処理を実装する．<code>PUT</code> 形式でデータを送信する．</p>
<blockquote>
<p><strong>Key Point</strong>💡</p>
<p><code>PUT</code> 形式は <code>GET</code> と <code>POST</code> が合わさったような形式で，<code>req.params.id</code> で id を送信し，同時に <code>req.body</code> で上書きするデータを送信する．</p>
<p>今回は使用しないが，<code>GET</code> でも同様に <code>req.params.id</code> で id を送信して受け取ることができる．</p>
</blockquote>
<h2 id="ルーティングの作成-3"><a class="header" href="#ルーティングの作成-3">ルーティングの作成</a></h2>
<p>update のルーティングを追加．</p>
<p>id 指定する．<code>/hoge</code> に <code>PUT</code> でリクエストを送信した場合，<code>req.params.id</code> は<code>hoge</code>になる．</p>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
// 🔽 編集
import {
  readAllTodoData,
  readTodayTodoData,
  createTodoData,
  editTodoData,
} from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
todoRouter.get(&quot;/today&quot;, (req, res) =&gt; readTodayTodoData(req, res));
todoRouter.post(&quot;/&quot;, (req, res) =&gt; createTodoData(req, res));
// 🔽 追加
todoRouter.put(&quot;/:id&quot;, (req, res) =&gt; editTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-3"><a class="header" href="#コントローラの作成-3">コントローラの作成</a></h2>
<p>コントローラでは，リクエストから <code>更新対象のドキュメントのid</code> と <code>更新データ</code> の 2 つを受け取る．送信されたデータの中から，これら 2 つのデータを抽出し，サービスに渡す．</p>
<pre><code class="language-js">// controllers/todo.controller.js

// 🔽 編集
import {
  getAllTodoData,
  getTodayTodoData,
  insertTodoData,
  updateTodoData,
} from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  //  省略
};

export const readTodayTodoData = async (req, res, next) =&gt; {
  // 省略
};

export const createTodoData = async (req, res, next) =&gt; {
  // 省略
};

// 🔽 追加
export const editTodoData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    const { user_id, todo, deadline, is_done } = req.body;
    if (
      !(
        id &amp;&amp;
        user_id &amp;&amp;
        todo &amp;&amp;
        deadline &amp;&amp;
        ![null, undefined].includes(is_done)
      )
    ) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await updateTodoData({
      id: id,
      params: {
        user_id: user_id,
        todo: todo,
        deadline: deadline,
        is_done: is_done,
      },
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully edit Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成-3"><a class="header" href="#サービスの作成-3">サービスの作成</a></h2>
<p>送信されたデータを渡すのみなのでこれまでの処理と同様．</p>
<pre><code class="language-js">// services/todo.service.js

import {
  findAll,
  findToday,
  store,
  update,
} from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  // 省略
};

export const getTodayTodoData = async () =&gt; {
  // 省略
};

export const insertTodoData = async ({ params }) =&gt; {
  // 省略
};

// 🔽 追加
export const updateTodoData = async ({ id, params }) =&gt; {
  try {
    return await update({ id, params });
  } catch (e) {
    throw Error(&quot;Error while updating Todo Data&quot;);
  }
};
</code></pre>
<h2 id="リポジトリの作成-3"><a class="header" href="#リポジトリの作成-3">リポジトリの作成</a></h2>
<p>リポジトリでは，受け取ったデータで DB を更新する．同時に <code>updated_at</code> に実行日時を設定して送信する．</p>
<p><code>update()</code> メソッドが用意されているのでこれを使用すれば OK．</p>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/update">https://supabase.com/docs/reference/javascript/update</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

export const findAll = async () =&gt; {
  // 省略
};

export const findToday = async () =&gt; {
  // 省略
};

export const store = async ({ params }) =&gt; {
  // 省略
};

// 🔽 追加
export const update = async ({ id, params }) =&gt; {
  try {
    const { data, error } = await supabase
      .from(&quot;todo_table&quot;)
      .update({ ...params, updated_at: new Date().toISOString() })
      .match({ id: id });
    return data;
  } catch (e) {
    throw Error(&quot;Error while updating Todo Data&quot;);
  }
};
</code></pre>
<h2 id="動作確認更新"><a class="header" href="#動作確認更新">動作確認（更新）</a></h2>
<p>動作確認する．更新前に適当なデータを確認し，更新状態が確認できるようにしておこう．</p>
<p>コンソール画面 or 前項の Read 処理でデータを確認し，データが更新されていれば OK！</p>
<pre><code class="language-bash">$ curl -X PUT -H &quot;Content-Type: application/json&quot; -d '{&quot;todo&quot;:&quot;Nest.js&quot;,&quot;user_id&quot;:2,&quot;deadline&quot;:&quot;2021-12-20&quot;,&quot;is_done&quot;:true}' localhost:3000/todo/2

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 2,
      &quot;user_id&quot;: 2,
      &quot;todo&quot;: &quot;Nest.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-20&quot;,
      &quot;is_done&quot;: true,
      &quot;created_at&quot;: &quot;2021-12-06T06:27:33.388245+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:56:33.618+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully edit Todo Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="delete-の処理"><a class="header" href="#delete-の処理">Delete の処理</a></h1>
<h2 id="データ削除の処理"><a class="header" href="#データ削除の処理">データ削除の処理</a></h2>
<p>id を指定して該当するデータを DB から削除する．テーブルと id を指定すれば OK．</p>
<h2 id="ルーティングの作成-4"><a class="header" href="#ルーティングの作成-4">ルーティングの作成</a></h2>
<p>削除のルーティングを追加．更新の場合と同様にパラメータを受け取る．</p>
<pre><code class="language-js">// routes/todo.route.js

import express from &quot;express&quot;;
// 🔽 編集
import {
  readAllTodoData,
  readTodayTodoData,
  createTodoData,
  editTodoData,
  deleteTodoData,
} from &quot;../controllers/todo.controller.js&quot;;

export const todoRouter = express.Router();

todoRouter.get(&quot;/&quot;, (req, res) =&gt; readAllTodoData(req, res));
todoRouter.get(&quot;/today&quot;, (req, res) =&gt; readTodayTodoData(req, res));
todoRouter.post(&quot;/&quot;, (req, res) =&gt; createTodoData(req, res));
todoRouter.put(&quot;/:id&quot;, (req, res) =&gt; editTodoData(req, res));
// 🔽 追加
todoRouter.delete(&quot;/:id&quot;, (req, res) =&gt; deleteTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-4"><a class="header" href="#コントローラの作成-4">コントローラの作成</a></h2>
<p>コントローラでは id を受け取り，サービスの処理を実行する．</p>
<pre><code class="language-js">// controllers/todo.controller.js

// 🔽 編集
import {
  getAllTodoData,
  getTodayTodoData,
  insertTodoData,
  updateTodoData,
  destroyTodoData,
} from &quot;../services/todo.service.js&quot;;

export const readAllTodoData = async (req, res, next) =&gt; {
  // 省略
};

export const readTodayTodoData = async (req, res, next) =&gt; {
  // 省略
};

export const createTodoData = async (req, res, next) =&gt; {
  // 省略
};

export const editTodoData = async (req, res, next) =&gt; {
  // 省略
};

// 🔽 追加
export const deleteTodoData = async (req, res, next) =&gt; {
  try {
    const { id } = req.params;
    if (!id) {
      throw new Error(&quot;something is blank&quot;);
    }
    const result = await destroyTodoData({
      id: id,
    });
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully delete Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成-4"><a class="header" href="#サービスの作成-4">サービスの作成</a></h2>
<p>サービスでは id 指定してリポジトリで定義した関数を実行する．</p>
<pre><code class="language-js">// services/todo.service.js

// 🔽 編集
import {
  findAll,
  findToday,
  store,
  update,
  destroy,
} from &quot;../repositories/todo.repository.js&quot;;

export const getAllTodoData = async () =&gt; {
  // 省略
};

export const getTodayTodoData = async () =&gt; {
  // 省略
};

export const insertTodoData = async ({ params }) =&gt; {
  // 省略
};

export const updateTodoData = async ({ id, params }) =&gt; {
  // 省略
};

// 🔽 追加
export const destroyTodoData = async ({ id }) =&gt; {
  try {
    return await destroy({ id: id });
  } catch (e) {
    throw Error(&quot;Error while deleting Todo Data&quot;);
  }
};
</code></pre>
<h2 id="リポジトリの作成-4"><a class="header" href="#リポジトリの作成-4">リポジトリの作成</a></h2>
<p>リポジトリでは DB からデータを削除する．id があればデータを指定して削除することができる．</p>
<p>参考：<a href="https://supabase.com/docs/reference/javascript/delete">https://supabase.com/docs/reference/javascript/delete</a></p>
<pre><code class="language-js">// repositories/todo.repository.js

import dotenv from &quot;dotenv&quot;;
import { createClient } from &quot;@supabase/supabase-js&quot;;

dotenv.config();

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_API_KEY
);

export const findAll = async () =&gt; {
  // 省略
};

export const findToday = async () =&gt; {
  // 省略
};

export const store = async ({ params }) =&gt; {
  // 省略
};

export const update = async ({ id, params }) =&gt; {
  // 省略
};

// 🔽 追加
export const destroy = async ({ id }) =&gt; {
  try {
    const { data, error } = await supabase
      .from(&quot;todo_table&quot;)
      .delete()
      .match({ id: id });
    return data;
  } catch (e) {
    throw Error(&quot;Error while deleting Todo Data&quot;);
  }
};
</code></pre>
<h2 id="動作確認削除"><a class="header" href="#動作確認削除">動作確認（削除）</a></h2>
<p>動作確認する．document 名 は既存のデータから適当に指定する．</p>
<p>コンソール画面 or 前項の Read 処理でデータを確認し，データが削除されていれば OK！</p>
<pre><code class="language-bash">$ curl -X DELETE localhost:3000/todo/13

{
  &quot;status&quot;: 200,
  &quot;result&quot;: [
    {
      &quot;id&quot;: 13,
      &quot;user_id&quot;: 1,
      &quot;todo&quot;: &quot;node.js&quot;,
      &quot;deadline&quot;: &quot;2021-12-31&quot;,
      &quot;is_done&quot;: false,
      &quot;created_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;,
      &quot;updated_at&quot;: &quot;2021-12-16T06:21:31.592284+00:00&quot;
    }
  ],
  &quot;message&quot;: &quot;Successfully delete Todo Data!&quot;
}

</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="slack-連携設定"><a class="header" href="#slack-連携設定">Slack 連携設定</a></h1>
<p>本項（と次の項）では，Slack で bot を作成し，todo の内容を投稿してもらう処理を実装する．</p>
<h3 id="step-1"><a class="header" href="#step-1">STEP 1</a></h3>
<p>まずは，以下 2 つのエンドポイントを作成して手動で実行する処理をつくる．</p>
<ul>
<li>
<p>todo リスト全件のデータを取得して Slack に投稿する．</p>
</li>
<li>
<p>実行日以前のデータのみ取得して Slack に投稿する．</p>
</li>
</ul>
<h3 id="step-2"><a class="header" href="#step-2">STEP 2</a></h3>
<p>上記の処理を利用し，指定した時間で定期実行するように処理を拡張する．</p>
<h2 id="slack-と連携するための設定"><a class="header" href="#slack-と連携するための設定">Slack と連携するための設定</a></h2>
<p>下記 URL にアクセスする．</p>
<p><a href="https://api.slack.com/">https://api.slack.com/</a></p>
<p><code>Create an app</code> をクリック．</p>
<p><img src="api-02/./img/slack-setup-01.png" alt="" /></p>
<p><code>From scratch</code> を選択．</p>
<p><img src="api-02/./img/slack-setup-02.png" alt="" /></p>
<p>「アプリ名（任意）」と「使用するワークスペース」を選択して <code>Create App</code> をクリック．</p>
<p><img src="api-02/./img/slack-setup-03.png" alt="" /></p>
<p>画面が変わるので，左側のメニューから <code>OAuth &amp; Permissions</code> → <code>Scopes</code> 部分の <code>Bot Token Scopes</code> を <code>chat:write</code> に設定する．</p>
<p><img src="api-02/./img/slack-setup-04.png" alt="" /></p>
<p><code>Install Workspace</code> がクリックできるようになっているのでクリックする．画面が変わったら <code>Allow</code> をクリック．</p>
<p><img src="api-02/./img/slack-setup-05.png" alt="" /></p>
<p><img src="api-02/./img/slack-setup-06.png" alt="" /></p>
<p>画面が変わるので <code>Bot User Access Token</code> をメモしておく．</p>
<p><img src="api-02/./img/slack-setup-07.png" alt="" /></p>
<p>Slack アプリ側で Bot を追加したい channel で「右上のメンバーボタン」→「Integrations」→ <code>Add an App</code> の順に進む．</p>
<p><img src="api-02/./img/slack-setup-08.png" alt="" /></p>
<p>作成したアプリ部分の <code>Add</code> ボタンをクリックする．</p>
<p><img src="api-02/./img/slack-setup-09.png" alt="" /></p>
<p>これでアプリ側の設定は完了．</p>
<h2 id="token-を環境変数に設定"><a class="header" href="#token-を環境変数に設定">Token を環境変数に設定</a></h2>
<p><code>.env</code> ファイルに <code>Bot User Access Token</code> を記述しておく．</p>
<pre><code class="language-txt">SUPABASE_API_KEY=hogefugapiyofoobar.eyJyb2xlIjoiYW5vbiIsImlhdCI6MTYzODc3MDU0NCwiZXhwIjoxOTU0MzQ2NTQ0fQ.FM4MwMd8wbPDGbXtnGfsn6bGSgMzBLdHOMGWRwhoK2I
SUPABASE_URL=https://hogehoge.supabase.co

SLACK_API_TOKEN=`取得した Bot User OAuth Token`
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="slack-連携実装"><a class="header" href="#slack-連携実装">Slack 連携実装</a></h1>
<p>最終的には定期実行になるが，まずは手動で動作させるため API を作成しておく．</p>
<p>（フロントにもテスト画面を実装して手動実行させられるようにしたい）</p>
<h2 id="準備"><a class="header" href="#準備">準備</a></h2>
<p>Node.js から Slack へ投稿するためにライブラリをインストールする．</p>
<pre><code class="language-bash">$ npm i @slack/web-api
</code></pre>
<p>また，Slack 連携の処理を実装するため，下記ファイルを作成しておく．</p>
<ul>
<li><code>routes/slack.route.js</code></li>
<li><code>controllers/slack.controller.js</code></li>
<li><code>services/slack.service.js</code></li>
</ul>
<p><code>app.js</code> を以下のように編集する．</p>
<pre><code class="language-js">// app.js

import express from &quot;express&quot;;
import { todoRouter } from &quot;./routes/todo.route.js&quot;;
// 🔽 追加
import { slackRouter } from &quot;./routes/slack.route.js&quot;;

const app = express();
app.use(express.urlencoded({ extended: true }));
app.use(express.json());
const port = 3001;

app.use(&quot;/todo&quot;, (req, res) =&gt; todoRouter(req, res));
// 🔽 追加
app.use(&quot;/slack&quot;, (req, res) =&gt; slackRouter(req, res));

app.listen(port, () =&gt; {
  console.log(`Example app listening at http://localhost:${port}`);
});
</code></pre>
<h2 id="ルーティングの作成-5"><a class="header" href="#ルーティングの作成-5">ルーティングの作成</a></h2>
<p>エンドポイントは 2 つ作成する．</p>
<ul>
<li><code>slack/</code> で todo リスト全件を Slack 投稿．</li>
<li><code>slack/today</code> で本日以前締切のデータのみを Slack 投稿．</li>
</ul>
<pre><code class="language-js">// routes/slack.route.js

import express from &quot;express&quot;;
import {
  sendAllTodoData,
  sendTodayTodoData,
} from &quot;../controllers/slack.controller.js&quot;;

export const slackRouter = express.Router();

slackRouter.get(&quot;/&quot;, (req, res) =&gt; sendAllTodoData(req, res));
slackRouter.get(&quot;/today&quot;, (req, res) =&gt; sendTodayTodoData(req, res));
</code></pre>
<h2 id="コントローラの作成-5"><a class="header" href="#コントローラの作成-5">コントローラの作成</a></h2>
<p>サービスの処理を呼び出しつつ，レスポンスを設定．</p>
<pre><code class="language-js">// controllers/slack.controller.js

import {
  postAllTodoData,
  postTodayTodoData,
} from &quot;../services/slack.service.js&quot;;

export const sendAllTodoData = async (req, res, next) =&gt; {
  try {
    const result = await postAllTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully send All Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};

export const sendTodayTodoData = async (req, res, next) =&gt; {
  try {
    const result = await postTodayTodoData();
    return res.status(200).json({
      status: 200,
      result: result,
      message: &quot;Successfully send Today Todo Data!&quot;,
    });
  } catch (e) {
    return res.status(400).json({ status: 400, message: e.message });
  }
};
</code></pre>
<h2 id="サービスの作成-5"><a class="header" href="#サービスの作成-5">サービスの作成</a></h2>
<p>メインのロジックを記述する．</p>
<p>Slack 連携のライブラリを読み込み，投稿の処理を実装する．</p>
<ul>
<li>
<p><code>postToSlack()</code> では <code>client.chat.postMessage</code> を使用し，任意の channel に任意のテキストを投稿している．</p>
</li>
<li>
<p><code>postAllTodoData()</code> では前項で実装した <code>findAll()</code> メソッドで全件データを取得し，<code>postToSlack()</code> メソッドで投稿を行う．</p>
</li>
<li>
<p><code>postTodayTodoData()</code> では前項で実装した <code>findToday()</code> メソッドで全件データを取得し，<code>postToSlack()</code> メソッドで投稿を行う．</p>
</li>
<li>
<p>（投稿のテキストはいい感じに作りましょう w）</p>
</li>
</ul>
<pre><code class="language-js">// services/slack.service.js

import { findAll, findToday } from &quot;../repositories/todo.repository.js&quot;;
import { WebClient } from &quot;@slack/web-api&quot;;
import dotenv from &quot;dotenv&quot;;

dotenv.config();

const postToSlack = async (token, channel, text) =&gt; {
  const client = new WebClient(token);
  const response = await client.chat.postMessage({ channel, text });
  console.log(response.ok);
  return response;
};

export const postAllTodoData = async () =&gt; {
  try {
    const token = process.env.SLACK_API_TOKEN;
    const todoData = await findAll();
    const text = todoData.map((x) =&gt; `${x.deadline}\t${x.todo}`).join(&quot;\n&quot;);
    return await postToSlack(token, &quot;#test&quot;, `現在のTodo！\n${text}`);
  } catch (e) {
    throw Error(&quot;Error while posting All Todo Data&quot;);
  }
};

export const postTodayTodoData = async () =&gt; {
  try {
    const token = process.env.SLACK_API_TOKEN;
    const todoData = await findToday();
    const text = todoData.map((x) =&gt; `${x.deadline}\t${x.todo}`).join(&quot;\n&quot;);
    return await postToSlack(token, &quot;#test&quot;, `本日締切！！\n${text}`);
  } catch (e) {
    throw Error(&quot;Error while posting Today Todo Data&quot;);
  }
};
</code></pre>
<h2 id="動作確認手動"><a class="header" href="#動作確認手動">動作確認（手動）</a></h2>
<p>設定したエンドポイントにリクエストを送って Slack に投稿されることを確認！</p>
<h3 id="全件投稿"><a class="header" href="#全件投稿">全件投稿</a></h3>
<pre><code class="language-bash">$ curl http://localhost:3000/slack

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;ok&quot;: true,
    &quot;channel&quot;: &quot;C01EF7W0YF3&quot;,
    &quot;ts&quot;: &quot;1639641376.000100&quot;,
    &quot;message&quot;: {
      &quot;bot_id&quot;: &quot;B01EF806CV7&quot;,
      &quot;type&quot;: &quot;message&quot;,
      &quot;text&quot;: &quot;現在のTodo！\n2021-12-04\treact\n2021-12-06\tnode.js\n2021-12-06\ttest\n2021-12-07\tzoom meeting\n2021-12-20\tNext.js\n2021-12-31\tnode.js\n2021-12-31\tnode.js\n2021-12-31\tnode.js\n2021-12-31\tnode.js\n2021-12-31\ttest&quot;,
      &quot;user&quot;: &quot;U01ESE8S9NU&quot;,
      &quot;ts&quot;: &quot;1639641376.000100&quot;,
      &quot;team&quot;: &quot;T4GCXGMGQ&quot;,
      &quot;bot_profile&quot;: {
        &quot;id&quot;: &quot;B01EF806CV7&quot;,
        &quot;app_id&quot;: &quot;A01E8PJTS04&quot;,
        &quot;name&quot;: &quot;cat-commander&quot;,
        &quot;icons&quot;: {
          &quot;image_36&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_36.png&quot;,
          &quot;image_48&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_48.png&quot;,
          &quot;image_72&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_72.png&quot;
        },
        &quot;deleted&quot;: false,
        &quot;updated&quot;: 1638887573,
        &quot;team_id&quot;: &quot;T4GCXGMGQ&quot;
      }
    },
    &quot;response_metadata&quot;: {
      &quot;scopes&quot;: [
        &quot;chat:write&quot;
      ],
      &quot;acceptedScopes&quot;: [
        &quot;chat:write&quot;
      ]
    }
  },
  &quot;message&quot;: &quot;Successfully send All Todo Data!&quot;
}
</code></pre>
<h3 id="実行日以前の締切のみ投稿"><a class="header" href="#実行日以前の締切のみ投稿">実行日以前の締切のみ投稿</a></h3>
<pre><code class="language-bash">$ curl http://localhost:3000/slack/today

{
  &quot;status&quot;: 200,
  &quot;result&quot;: {
    &quot;ok&quot;: true,
    &quot;channel&quot;: &quot;C01EF7W0YF3&quot;,
    &quot;ts&quot;: &quot;1639641433.000200&quot;,
    &quot;message&quot;: {
      &quot;bot_id&quot;: &quot;B01EF806CV7&quot;,
      &quot;type&quot;: &quot;message&quot;,
      &quot;text&quot;: &quot;本日締切！！\n2021-12-04\treact\n2021-12-06\tnode.js\n2021-12-06\ttest\n2021-12-07\tzoom meeting&quot;,
      &quot;user&quot;: &quot;U01ESE8S9NU&quot;,
      &quot;ts&quot;: &quot;1639641433.000200&quot;,
      &quot;team&quot;: &quot;T4GCXGMGQ&quot;,
      &quot;bot_profile&quot;: {
        &quot;id&quot;: &quot;B01EF806CV7&quot;,
        &quot;app_id&quot;: &quot;A01E8PJTS04&quot;,
        &quot;name&quot;: &quot;cat-commander&quot;,
        &quot;icons&quot;: {
          &quot;image_36&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_36.png&quot;,
          &quot;image_48&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_48.png&quot;,
          &quot;image_72&quot;: &quot;https://avatars.slack-edge.com/2021-12-07/2833480487664_be12a9ce689e9e465952_72.png&quot;
        },
        &quot;deleted&quot;: false,
        &quot;updated&quot;: 1638887573,
        &quot;team_id&quot;: &quot;T4GCXGMGQ&quot;
      }
    },
    &quot;response_metadata&quot;: {
      &quot;scopes&quot;: [
        &quot;chat:write&quot;
      ],
      &quot;acceptedScopes&quot;: [
        &quot;chat:write&quot;
      ]
    }
  },
  &quot;message&quot;: &quot;Successfully send Today Todo Data!&quot;
}

</code></pre>
<h2 id="定期実行の設定"><a class="header" href="#定期実行の設定">定期実行の設定</a></h2>
<p>手動で投稿する実装が完了したら，時間を指定して定期実行する処理を実装する．</p>
<p>定期実行には <code>node-cron</code> ライブラリを用いる．</p>
<ul>
<li>
<p>時間を指定しておくと自動で任意の処理を実行してくれる．</p>
</li>
<li>
<p>時間指定には 6 つの数値を用いる．順番が決まっており，以下の通りである．</p>
</li>
</ul>
<pre><code class="language-txt"> # ┌────────────── second (optional)
 # │ ┌──────────── minute
 # │ │ ┌────────── hour
 # │ │ │ ┌──────── day of month
 # │ │ │ │ ┌────── month
 # │ │ │ │ │ ┌──── day of week
 # │ │ │ │ │ │
 # │ │ │ │ │ │
 # * * * * * *

</code></pre>
<p>参考：<a href="https://github.com/node-cron/node-cron">https://github.com/node-cron/node-cron</a></p>
<h3 id="ライブラリのインストール"><a class="header" href="#ライブラリのインストール">ライブラリのインストール</a></h3>
<p>下記コマンドを実行してライブラリをインストールする．</p>
<pre><code class="language-bash">$ npm i node-cron
</code></pre>
<h3 id="定期実行の処理を追記"><a class="header" href="#定期実行の処理を追記">定期実行の処理を追記</a></h3>
<p>サービスの処理でライブラリを読み込み，定期実行の処理を追記する．</p>
<pre><code class="language-js">// services/slack.service.js

import { findAll, findToday } from &quot;../repositories/todo.repository.js&quot;;
import { WebClient } from &quot;@slack/web-api&quot;;
import dotenv from &quot;dotenv&quot;;
// 🔽 追加
import cron from &quot;node-cron&quot;;

dotenv.config();

const postToSlack = async (token, channel, text) =&gt; {
  // 省略
};

export const postAllTodoData = async () =&gt; {
  // 省略
};

export const postTodayTodoData = async () =&gt; {
  // 省略
};

// 例：日時設定せずに 3 秒毎に実行
// cron.schedule('*/3 * * * * *', () =&gt; console.log('3秒ごとに実行'));

// 例：毎日 19 時 30 分 30 秒と 19 時 30 分 40 秒に実行
cron.schedule(&quot;30 30 19 * * *&quot;, () =&gt; postAllTodoData());
cron.schedule(&quot;40 30 19 * * *&quot;, () =&gt; postTodayTodoData());
</code></pre>
<h2 id="動作確認定期実行"><a class="header" href="#動作確認定期実行">動作確認（定期実行）</a></h2>
<p>指定した時間に slack に投稿が行われれば OK！</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="まとめ-1"><a class="header" href="#まとめ-1">まとめ</a></h1>
<p>今回は Node.js におけるデータの永続化を扱った．DB は Supabase を用いたが，他の DB でも処理の手順は大凡同様である．</p>
<p>今回はリポジトリパターンの実装で DB 関連の処理を別のレイヤーに切り出した．このようにすることで，DB 変更時にもコードの修正を該当レイヤーのみに閉じ込めることができる．</p>
<p>slack との連携では連携のための設定と，todo アプリケーションの内容を投稿する処理を実装した．投稿自体はそれほど難しい処理ではないため，他の処理と組み合わせることで様々なアプリケーションを実装できるだろう．</p>
<p><strong>今回実装したアプリケーションは次回のオンライン講義で使用するため，動く状態でそのままにしておくこと！</strong></p>
<p>今回は以上である( `･ω･´)b</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
